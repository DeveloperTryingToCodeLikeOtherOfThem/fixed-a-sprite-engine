{"entries":[{"timestamp":1756165259441,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":173,"length1":196,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":202,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"sprite.ts","value":"enum SpriteFlag2 {\n    //% block=\"ghost\"\n    Ghost = sprites2.Flag.Ghost,\n    //% block=\"auto destroy\"\n    AutoDestroy = sprites2.Flag.AutoDestroy,\n    //% block=\"stay in screen\"\n    StayInScreen = sprites2.Flag.StayInScreen,\n    //% block=\"destroy on wall\"\n    DestroyOnWall = sprites2.Flag.DestroyOnWall,\n    //% block=\"bounce on wall\"\n    BounceOnWall = sprites2.Flag.BounceOnWall,\n    //% block=\"show physics\"\n    ShowPhysics = sprites2.Flag.ShowPhysics\n}\n\nenum CollisionDirection2 {\n    //% block=\"left\"\n    Left = 0,\n    //% block=\"top\"\n    Top = 1,\n    //% block=\"right\"\n    Right = 2,\n    //% block=\"bottom\"\n    Bottom = 3\n}\n\ninterface SpriteLike2 {\n    z: number;\n    id: number;\n    __update(camera: scene.Camera, dt: number): void;\n    __draw(camera: scene.Camera): void;\n    __serialize(offset: number): Buffer;\n}\n\nenum FlipOption2 {\n    //% block=none\n    None,\n    //% block=\"flip x\"\n    FlipX,\n    //% block=\"flip y\"\n    FlipY,\n    //% block=\"flip x+y\"\n    FlipXY\n}\n\n/**\n * A sprite on the screen\n **/\n//% blockNamespace=sprites color=\"#4B7BEC\" blockGap=8\nclass Sprite2 implements SpriteLike2 {\n    _x: Fx8\n    _y: Fx8\n    private _z: number\n    _vx: Fx8\n    _vy: Fx8\n    _ax: Fx8\n    _ay: Fx8\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\"\n    get x(): number {\n        return Fx.toInt(this._x) + (this._image.width >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\"\n    set x(v: number) {\n        this._lastX = this._x;\n        this._x = Fx8(v - (this._image.width >> 1))\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\"\n    get y(): number {\n        return Fx.toInt(this._y) + (this._image.height >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\"\n    set y(v: number) {\n        this._lastY = this._y;\n        this._y = Fx8(v - (this._image.height >> 1))\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\"\n    get vx(): number {\n        return Fx.toFloat(this._vx)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\"\n    set vx(v: number) {\n        this._vx = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\"\n    get vy(): number {\n        return Fx.toFloat(this._vy)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\"\n    set vy(v: number) {\n        this._vy = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\"\n    get ax(): number {\n        return Fx.toFloat(this._ax)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\"\n    set ax(v: number) {\n        this._ax = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\"\n    get ay(): number {\n        return Fx.toFloat(this._ay)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\"\n    set ay(v: number) {\n        this._ay = Fx8(v)\n    }\n\n    /** \n     * Custom data\n     */\n    //%\n    data: any;\n    _kind: number;\n\n    /**\n     * A bitset of layer. Each bit is a layer, default is 1.\n     */\n    //% group=\"Physics\"\n    layer: number;\n\n    _lastX: Fx8;\n    _lastY: Fx8;\n\n    _action: number; //Used with animation library\n\n    /**\n     * Time to live in milliseconds. The lifespan decreases by 1 on each millisecond\n     * and the sprite gets destroyed when it reaches 0.\n     */\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"lifespan\"\n    lifespan: number;\n    private _image: Image;\n    private _obstacles: sprites.Obstacle[];\n\n    private updateSay: (dt: number, camera: scene.Camera) => void;\n    private sayBubbleSprite: Sprite;\n\n    _hitbox: game.Hitbox;\n    _overlappers: number[];\n\n    flags: number\n    id: number\n\n    overlapHandler: (other: Sprite) => void;\n    collisionHandlers: (() => void)[][];\n    private destroyHandler: () => void;\n\n    constructor(img: Image) {\n        this._x = Fx8(screen.width - img.width >> 1);\n        this._y = Fx8(screen.height - img.height >> 1);\n        this._z = 0\n        this._lastX = this._x;\n        this._lastY = this._y;\n        this.vx = 0\n        this.vy = 0\n        this.ax = 0\n        this.ay = 0\n        this.flags = 0\n        this.setImage(img);\n        this.setKind(-1); // not a member of any type by default\n        this.layer = 1; // by default, in layer 1\n        this.lifespan = undefined;\n        this._overlappers = [];\n    }\n\n    __serialize(offset: number): Buffer {\n        const buf = control.createBuffer(offset + 12);\n        let k = offset;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._x)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._y)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vx)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vy)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ax)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ay)); k += 2;\n        return buf;\n    }\n\n    /**\n     * Gets the current image\n     */\n    //% group=\"Lifecycle\"\n    //% blockId=spriteimage block=\"%sprite(mySprite) image\"\n    //% weight=8\n    get image(): Image {\n        return this._image;\n    }\n\n    /**\n     * Sets the image on the sprite\n     */\n    //% group=\"Lifecycle\"\n    //% blockId=spritesetimage block=\"set %sprite(mySprite) image to %img=screen_image_picker\"\n    //% weight=7 help=sprites/sprite/set-image\n    setImage(img: Image) {\n        if (!img) return; // don't break the sprite\n\n        let oMinX = 0;\n        let oMinY = 0;\n        let oMaxX = 0;\n        let oMaxY = 0;\n\n        // Identify old upper left corner\n        if (this._hitbox) {\n            oMinX = this._hitbox.ox;\n            oMinY = this._hitbox.oy;\n            oMaxX = this._hitbox.ox + this._hitbox.width;\n            oMaxY = this._hitbox.oy + this._hitbox.height;\n        }\n\n        this._image = img;\n        this._hitbox = game.calculateHitBox(this);\n\n        // Identify new upper left corner\n        let nMinX = this._hitbox.ox;\n        let nMinY = this._hitbox.oy;\n        let nMaxX = this._hitbox.ox + this._hitbox.width;\n        let nMaxY = this._hitbox.oy + this._hitbox.height;\n\n        const minXDiff = oMinX - nMinX;\n        const minYDiff = oMinY - nMinY;\n        const maxXDiff = oMaxX - nMaxX;\n        const maxYDiff = oMaxY - nMaxY;\n\n        // If just a small change to the hitbox, don't change the hitbox\n        // Used for things like walking animations\n        if (oMaxX != oMinX && Math.abs(minXDiff) + Math.abs(maxXDiff) <= 2) {\n            this._hitbox.ox = oMinX;\n            this._hitbox.width = oMaxX - oMinX;\n        }\n        if (oMaxY != oMinY && Math.abs(minYDiff) + Math.abs(maxYDiff) <= 2) {\n            this._hitbox.oy = oMinY;\n            this._hitbox.height = oMaxY - oMinY;\n        }\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    get z(): number {\n        return this._z;\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    set z(value: number) {\n        if (value != this._z) {\n            this._z = value;\n            game.currentScene().flags |= scene.Flag.NeedsSorting;\n        }\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"width\"\n    get width() {\n        return this._image.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"height\"\n    get height() {\n        return this._image.height\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    get left() {\n        return Fx.toInt(this._x)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    set left(value: number) {\n        this._x = Fx8(value)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    get right() {\n        return this.left + this.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    set right(value: number) {\n        this.left = value - this.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    get top() {\n        return Fx.toInt(this._y);\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    set top(value: number) {\n        this._y = Fx8(value);\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    get bottom() {\n        return this.top + this.height;\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    set bottom(value: number) {\n        this.top = value - this.height;\n    }\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritegetkind\" block=\"%sprite(mySprite) kind\"\n    //% weight=79 help=sprites/sprite/kind\n    kind() {\n        return this._kind;\n    }\n\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritesetkind\" block=\"set %sprite(mySprite) kind to %kind\"\n    //% kind.shadow=spritetype\n    //% weight=80 help=sprites/sprite/set-kind\n    setKind(value: number) {\n        if (value == undefined || this._kind === value) return;\n\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (this._kind >= 0 && spritesByKind[this._kind])\n            spritesByKind[this._kind].remove(this);\n\n        if (value >= 0) {\n            if (!spritesByKind[value]) spritesByKind[value] = new SpriteSet();\n            spritesByKind[value].add(this);\n        }\n\n        this._kind = value;\n    }\n\n    /**\n     * Set the sprite position in pixels starting from the top-left corner of the screen.\n     * @param x horizontal position in pixels\n     * @param y vertical position in pixels\n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetpos block=\"set %sprite(mySprite) position to x %x y %y\"\n    //% help=sprites/sprite/set-position\n    //% x.shadow=\"positionPicker\" y.shadow=\"positionPicker\"\n    setPosition(x: number, y: number): void {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Sets the sprite velocity in pixel / sec\n     * @param vx \n     * @param vy \n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetvel block=\"set %sprite(mySprite) velocity to vx %vx vy %vy\"\n    //% help=sprites/sprite/set-velociy\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    setVelocity(vx: number, vy: number): void {\n        this.vx = vx;\n        this.vy = vy;\n    }\n\n    /**\n     * Display a speech bubble with the text, for the given time\n     * @param text the text to say, eg: \":)\"\n     * @param time time to keep text on\n     */\n    //% group=\"Effects\"\n    //% weight=60\n    //% blockId=spritesay block=\"%sprite(mySprite) say %text||for %millis ms\"\n    //% millis.shadow=timePicker\n    //% inlineInputMode=inline\n    //% help=sprites/sprite/say\n    say(text: string, timeOnScreen?: number, textColor = 15, textBoxColor = 1) {\n        if (!text) {\n            this.updateSay = undefined;\n            if (this.sayBubbleSprite) {\n                this.sayBubbleSprite.destroy();\n                this.sayBubbleSprite = undefined;\n            }\n            return;\n        }\n\n        let pixelsOffset = 0;\n        let holdTextSeconds = 1.5;\n        let bubblePadding = 4;\n        let maxTextWidth = 100;\n        let font = image.font8;\n        let startX = 2;\n        let startY = 2;\n        let bubbleWidth = text.length * font.charWidth + bubblePadding;\n        let maxOffset = text.length * font.charWidth - maxTextWidth;\n        let bubbleOffset: number = this._hitbox.oy;\n        // sets the defaut scroll speed in pixels per second\n        let speed = 45;\n        const currentScene = game.currentScene();\n\n        // Calculates the speed of the scroll if scrolling is needed and a time is specified\n        if (timeOnScreen && maxOffset > 0) {\n            speed = (maxOffset + (2 * maxTextWidth)) / (timeOnScreen / 1000);\n            speed = Math.max(speed, 45);\n            holdTextSeconds = maxTextWidth / speed;\n            holdTextSeconds = Math.min(holdTextSeconds, 1.5);\n        }\n\n        if (timeOnScreen) {\n            timeOnScreen = timeOnScreen + currentScene.millis();\n        }\n\n        if (bubbleWidth > maxTextWidth + bubblePadding) {\n            bubbleWidth = maxTextWidth + bubblePadding;\n        } else {\n            maxOffset = -1;\n        }\n\n        // Destroy previous sayBubbleSprite to prevent leaking\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n            this.sayBubbleSprite = undefined;\n        }\n\n        this.sayBubbleSprite = sprites.create(image.create(bubbleWidth, font.charHeight + bubblePadding), -1);\n\n        this.sayBubbleSprite.setFlag(SpriteFlag.Ghost, true);\n        this.updateSay = (dt, camera) => {\n            // Update box stuff as long as timeOnScreen doesn't exist or it can still be on the screen\n            if (!timeOnScreen || timeOnScreen > currentScene.millis()) {\n                this.sayBubbleSprite.image.fill(textBoxColor);\n                // The minus 2 is how much transparent padding there is under the sayBubbleSprite\n                this.sayBubbleSprite.y = this.top + bubbleOffset - ((font.charHeight + bubblePadding) >> 1) - 2;\n                this.sayBubbleSprite.x = this.x;\n\n                if (!this.isOutOfScreen(camera)) {\n                    const ox = camera.offsetX;\n                    const oy = camera.offsetY;\n\n                    if (this.sayBubbleSprite.left - ox < 0) {\n                        this.sayBubbleSprite.left = 0;\n                    }\n\n                    if (this.sayBubbleSprite.right - ox > screen.width) {\n                        this.sayBubbleSprite.right = screen.width;\n                    }\n\n                    // If sprite bubble above the sprite gets cut off on top, place the bubble below the sprite\n                    if (this.sayBubbleSprite.top - oy < 0) {\n                        this.sayBubbleSprite.y = (this.sayBubbleSprite.y - 2 * this.y) * -1;\n                    }\n                }\n\n                // Pauses at beginning of text for holdTextSeconds length\n                if (holdTextSeconds > 0) {\n                    holdTextSeconds -= game.eventContext().deltaTime;\n                    // If scrolling has reached the end, start back at the beginning\n                    if (holdTextSeconds <= 0 && pixelsOffset > 0) {\n                        pixelsOffset = 0;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                } else {\n                    pixelsOffset += dt * speed;\n\n                    // Pause at end of text for holdTextSeconds length\n                    if (pixelsOffset >= maxOffset) {\n                        pixelsOffset = maxOffset;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                }\n                // If maxOffset is negative it won't scroll\n                if (maxOffset < 0) {\n                    this.sayBubbleSprite.image.print(text, startX, startY, textColor, font);\n                } else {\n                    this.sayBubbleSprite.image.print(text, startX - pixelsOffset, startY, textColor, font);\n                }\n\n                // Left side padding\n                this.sayBubbleSprite.image.fillRect(0, 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                // Right side padding\n                this.sayBubbleSprite.image.fillRect(bubbleWidth - (bubblePadding >> 1), 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                // Corners removed\n                this.sayBubbleSprite.image.setPixel(0, 0, 0);\n                this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, 0, 0);\n                this.sayBubbleSprite.image.setPixel(0, font.charHeight + bubblePadding - 1, 0);\n                this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, font.charHeight + bubblePadding - 1, 0);\n            } else {\n                // If can't update because of timeOnScreen then destroy the sayBubbleSprite and reset updateSay\n                this.sayBubbleSprite.destroy();\n                this.updateSay = undefined;\n            }\n        }\n    }\n\n    /**\n     * Start an effect on this sprite\n     * @param effect the type of effect to create\n     */\n    //% group=\"Effects\"\n    //% weight=90\n    //% blockId=startEffectOnSprite block=\"%sprite(mySprite) start %effect effect || for %duration=timePicker|ms\"\n    startEffect(effect: effects.ParticleEffect, duration?: number) {\n        effect.start(this, duration);\n    }\n\n    /**\n     * Indicates if the sprite is outside the screen\n     */\n    //%\n    isOutOfScreen(camera: scene.Camera): boolean {\n        const ox = camera.offsetX;\n        const oy = camera.offsetY;\n        return this.right - ox < 0 || this.bottom - oy < 0 || this.left - ox > screen.width || this.top - oy > screen.height;\n    }\n\n    __draw(camera: scene.Camera) {\n        if (this.isOutOfScreen(camera)) return;\n\n        const l = this.left - camera.drawOffsetX;\n        const t = this.top - camera.drawOffsetY;\n        screen.drawTransparentImage(this._image, l, t)\n\n        if (this.flags & SpriteFlag.ShowPhysics) {\n            const font = image.font5;\n            const margin = 2;\n            let tx = this.left;\n            let ty = this.bottom + margin;\n            screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n            tx -= font.charWidth;\n            if (this.vx || this.vy) {\n                ty += font.charHeight + margin;\n                screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n            }\n            if (this.ax || this.ay) {\n                ty += font.charHeight + margin;\n                screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n            }\n        }\n\n        // debug info\n        if (game.debug) {\n            screen.drawRect(Fx.toInt(this._hitbox.left), Fx.toInt(this._hitbox.top), this._hitbox.width, this._hitbox.height, 1);\n        }\n    }\n\n    __update(camera: scene.Camera, dt: number) {\n        if (this.lifespan !== undefined) {\n            this.lifespan -= dt * 1000;\n            if (this.lifespan <= 0) {\n                this.lifespan = undefined;\n                this.destroy();\n            }\n        }\n        if ((this.flags & sprites.Flag.AutoDestroy)\n            && this.isOutOfScreen(camera)) {\n            this.destroy()\n        }\n\n        const bounce = this.flags & sprites.Flag.BounceOnWall;\n        const tm = game.currentScene().tileMap;\n        if (this.flags & sprites.Flag.StayInScreen || (bounce && !tm)) {\n            if (this.left < camera.offsetX) {\n                this.left = camera.offsetX;\n                if (bounce) this.vx = -this.vx;\n            }\n            else if (this.right > camera.offsetX + screen.width) {\n                this.right = camera.offsetX + screen.width;\n                if (bounce) this.vx = -this.vx;\n            }\n\n            if (this.top < camera.offsetY) {\n                this.top = camera.offsetY;\n                if (bounce) this.vy = -this.vy;\n            }\n            else if (this.bottom > camera.offsetY + screen.height) {\n                this.bottom = camera.offsetY + screen.height;\n                if (bounce) this.vy = -this.vy;\n            }\n        }\n\n        // Say text\n        if (this.updateSay) {\n            this.updateSay(dt, camera);\n        }\n    }\n\n    /**\n     * Set a sprite flag\n     */\n    //% group=\"Effects\"\n    //% weight=30\n    //% blockId=spritesetsetflag block=\"set %sprite(mySprite) %flag %on=toggleOnOff\"\n    //% flag.defl=SpriteFlag.StayInScreen\n    //% help=sprites/sprite/set-flag\n    setFlag(flag: SpriteFlag, on: boolean) {\n        if (on) this.flags |= flag\n        else this.flags = ~(~this.flags | flag);\n    }\n\n    /**\n     * Check if this sprite overlaps another sprite\n     * @param other\n     */\n    //% group=\"Overlaps\"\n    //% blockId=spriteoverlapswith block=\"%sprite(mySprite) overlaps with %other=variables_get(otherSprite)\"\n    //% help=sprites/sprite/overlaps-with\n    //% weight=90\n    overlapsWith(other: Sprite) {\n        control.enablePerfCounter(\"overlapsCPP\")\n        if (other == this) return false;\n        if (this.flags & sprites.Flag.Ghost)\n            return false\n        if (other.flags & sprites.Flag.Ghost)\n            return false\n        return other._image.overlapsWith(this._image, this.left - other.left, this.top - other.top)\n    }\n\n    /**\n     * Registers code when the sprite overlaps with another sprite\n     * @param spriteType sprite type to match\n     * @param handler\n     */\n    //% group=\"Overlaps\"\n    //% afterOnStart=true\n    //% help=sprites/sprite/on-overlap\n    onOverlap(handler: (other: Sprite) => void) {\n        this.overlapHandler = handler;\n    }\n\n    /**\n     * Registers code when the sprite collides with an obstacle\n     * @param direction\n     * @param handler\n     */\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    onCollision(direction: CollisionDirection, tileIndex: number, handler: () => void) {\n        if (!this.collisionHandlers)\n            this.collisionHandlers = [];\n\n        direction = Math.max(0, Math.min(3, direction | 0));\n\n        if (!this.collisionHandlers[direction])\n            this.collisionHandlers[direction] = [];\n\n        this.collisionHandlers[direction][tileIndex] = handler;\n    }\n\n    /**\n     * Check if there is an obstacle in the given direction\n     * @param direction\n     */\n    //% blockId=spritehasobstacle block=\"is %sprite(mySprite) hitting wall %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/is-hitting-tile\n    isHittingTile(direction: CollisionDirection): boolean {\n        return this._obstacles && !!this._obstacles[direction];\n    }\n\n    /**\n     * Get the obstacle sprite in a given direction if any\n     * @param direction\n     */\n    //% blockId=spriteobstacle block=\"%sprite(mySprite) wall hit on %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/tile-hit-from\n    tileHitFrom(direction: CollisionDirection): number {\n        return (this._obstacles && this._obstacles[direction]) ? this._obstacles[direction].tileIndex : -1;\n    }\n\n    clearObstacles() {\n        this._obstacles = undefined;\n    }\n\n    registerObstacle(direction: CollisionDirection, other: sprites.Obstacle) {\n        if (other == undefined) return;\n        if (!this._obstacles)\n            this._obstacles = [];\n        this._obstacles[direction] = other;\n\n        const handler = (this.collisionHandlers && this.collisionHandlers[direction]) ? this.collisionHandlers[direction][other.tileIndex] : undefined;\n        if (handler) handler();\n        const scene = game.currentScene();\n        scene.collisionHandlers\n            .filter(h => h.kind == this.kind() && h.tile == other.tileIndex)\n            .forEach(h => h.handler(this));\n    }\n\n    /**\n     * Run code when the sprite is destroyed\n     * @param handler\n     */\n    //% group=\"Lifecycle\"\n    //% weight=9\n    onDestroyed(handler: () => void) {\n        this.destroyHandler = handler\n    }\n\n    /**\n     * Destroy the sprite\n     */\n    //% group=\"Effects\"\n    //% weight=80\n    //% blockId=spritedestroy block=\"destroy %sprite(mySprite) || with %effect effect\"\n    //% help=sprites/sprite/destroy\n    destroy(effect?: effects.ParticleEffect) {\n        if (this.flags & sprites.Flag.Destroyed)\n            return;\n\n        if (effect) {\n            effect.destroy(this);\n            return;\n        }\n\n        this.flags |= sprites.Flag.Destroyed\n        const scene = game.currentScene();\n        // When current sprite is destroyed, destroys sayBubbleSprite if defined\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n        }\n        scene.allSprites.removeElement(this);\n        if (this.kind() >= 0 && scene.spritesByKind[this.kind()])\n            scene.spritesByKind[this.kind()].remove(this);\n        scene.physicsEngine.removeSprite(this);\n        if (this.destroyHandler)\n            this.destroyHandler();\n        scene.destroyedHandlers\n            .filter(h => h.kind == this.kind())\n            .forEach(h => h.handler(this));\n    }\n\n    toString() {\n        return `${this.id}(${this.x},${this.y})->(${this.vx},${this.vy})`;\n    }\n}"},{"type":"added","filename":"sprites.ts","value":"// Add your code here\n/*\nFrame handlers:\n 10 - physics and collisions\n 20 - frame()\n 60 - screen/sprite background\n 90 - drawing sprites\n 95 - drawing score\n100 - loops.menu()\n200 - screen refresh\n*/\n\n/**\n * Sprites on screen\n */\n//% weight=99 color=\"#4B7BEC\" icon=\"\\uf1d8\"\n//% groups='[\"Create\", \"Physics\", \"Effects\", \"Projectiles\", \"Overlaps\", \"Lifecycle\"]'\nnamespace sprites2 {\n\n    /**\n     * Create a new sprite from an image\n     * @param img the image\n     */\n    //% group=\"Create\"\n    //% blockId=spritescreate block=\"sprite %img=screen_image_picker of kind %kind=spritetype\"\n    //% expandableArgumentMode=toggle\n    //% blockSetVariable=mySprite\n    //% weight=100 help=sprites/create\n    export function create(img: Image, kind?: number): Sprite2 {\n        const scene = game.currentScene();\n        const sprite = new Sprite2(img)\n        sprite.setKind(kind);\n        scene.addSprite(sprite);\n        scene.physicsEngine.addSprite(sprite);\n\n        // run on created handlers\n        scene.createdHandlers\n            .filter(h => h.kind == kind)\n            .forEach(h => h.handler(sprite));\n\n        return sprite\n    }\n\n    /**\n     * Return an array of all sprites of the given kind.\n     * @param kind the target kind\n     */\n    //% blockId=allOfKind block=\"array of sprites of kind %kind=spritetype\"\n    //% blockNamespace=\"arrays\" blockSetVariable=\"sprite list\"\n    //% weight=87\n    export function allOfKind(kind: number): Sprite[] {\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (!(kind >= 0) || !spritesByKind[kind]) return [];\n        else return spritesByKind[kind].sprites();\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromside block=\"projectile %img=screen_image_picker from side with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-side\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSide(img: Image, vx: number, vy: number) {\n        return createProjectile(img, vx, vy, 1);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromsprite block=\"projectile %img=screen_image_picker from %sprite=variables_get(mySprite) with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-sprite\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSprite(img: Image, sprite: Sprite, vx: number, vy: number): Sprite {\n        return createProjectile(img, vx, vy, 1, sprite);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectile block=\"projectile %img=screen_image_picker vx %vx vy %vy of kind %kind=spritetype||from sprite %sprite=variables_get(mySprite)\"\n    //% weight=99 help=sprites/create-projectile\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% expandableArgumentMode=toggle\n    //% vy.defl=100\n    //% deprecated=true blockHidden=true\n    export function createProjectile(img: Image, vx: number, vy: number, kind?: number, sprite?: Sprite) {\n        const s = sprites.create(img, kind);\n        const sc = game.currentScene();\n        s.vx = vx\n        s.vy = vy\n\n        // put it at the edge of the screen so that it moves towards the middle\n        // If the scene has a tile map, place the sprite fully on the screen\n\n        const xOff = sc.tileMap ? -(s.width >> 1) : (s.width >> 1) - 1;\n        const yOff = sc.tileMap ? -(s.height >> 1) : (s.height >> 1) - 1;\n\n        while (vx == 0 && vy == 0) {\n            vx = Math.randomRange(-100, 100);\n            vy = Math.randomRange(-100, 100);\n        }\n\n        if (vx < 0)\n            s.x = screen.width + xOff\n        else if (vx > 0)\n            s.x = -xOff\n\n        if (vy < 0)\n            s.y = screen.height + yOff\n        else if (vy > 0)\n            s.y = -yOff\n\n        s.flags |= sprites.Flag.AutoDestroy;\n        s.flags |= sprites.Flag.DestroyOnWall;\n\n        if (sprite) {\n            s.x = sprite.x;\n            s.y = sprite.y;\n        }\n\n        return s\n    }\n\n    export enum Flag {\n        Ghost = 1 << 0, // doesn't collide with other sprites\n        Destroyed = 1 << 1,\n        AutoDestroy = 1 << 2, // remove the sprite when no longer visible\n        StayInScreen = 1 << 3, // sprite cannot move outside the camera region\n        DestroyOnWall = 1 << 4, // destroy sprite on contact with wall\n        BounceOnWall = 1 << 5, // Bounce on walls\n        ShowPhysics = 1 << 6, // display position, velocity, acc\n    }\n}\n"},{"type":"added","filename":"physics.ts","value":"// Add your code here\nclass PhysicsEngine2 {\n    constructor() {\n    }\n\n    /**\n     * Adds sprite to the physics\n     * @param sprite\n     */\n    addSprite(sprite: Sprite2) { }\n\n    removeSprite(sprite: Sprite2) { }\n\n    moveSprite(s: Sprite2, tm: tiles2.TileMap, dx: Fx8, dy: Fx8) { }\n\n    draw() { }\n\n    /** Apply physics */\n    move(dt: number) { }\n\n    /**\n     * Apply collisions\n     */\n    collisions() { }\n\n    overlaps(sprite: Sprite2): Sprite2[] { return []; }\n}\n\nconst MAX_DISTANCE = Fx8(15); // pixels\nconst MAX_TIME_STEP2 = Fx8(0.1); // seconds\nconst MAX_VELOCITY = Fx.div(MAX_DISTANCE, MAX_TIME_STEP);\nconst NEG_MAX_VELOCITY = Fx.neg(MAX_VELOCITY)\nconst GAP = Fx8(0.1);\n\n/**\n * A physics engine that does simple AABB bounding box check\n */\nclass ArcadePhysicsEngine extends PhysicsEngine {\n    protected sprites: Sprite[];\n    protected map: sprites.SpriteMap;\n\n    constructor() {\n        super();\n        this.sprites = [];\n    }\n\n    addSprite(sprite: Sprite) {\n        this.sprites.push(sprite);\n    }\n\n    removeSprite(sprite: Sprite) {\n        this.sprites.removeElement(sprite);\n    }\n\n    draw() {\n        if (this.map)\n            this.map.draw();\n    }\n\n    move(dt: number) {\n        const dtf = Fx.min(MAX_TIME_STEP, Fx8(dt))\n        const dt2 = Fx.idiv(dtf, 2)\n\n        const tm = game.currentScene().tileMap;\n\n        for (let s of this.sprites) {\n            const ovx = constrain(s._vx);\n            const ovy = constrain(s._vy);\n\n            s._vx = constrain(Fx.add(s._vx, Fx.mul(s._ax, dtf)))\n            s._vy = constrain(Fx.add(s._vy, Fx.mul(s._ay, dtf)))\n\n            this.moveSprite(s, tm,\n                Fx.mul(Fx.add(s._vx, ovx), dt2),\n                Fx.mul(Fx.add(s._vy, ovy), dt2))\n        }\n    }\n\n    collisions() {\n        control.enablePerfCounter(\"phys_collisions\")\n\n        // 1: refresh non-ghost collision map\n        const colliders = this.sprites.filter(sprite => !(sprite.flags & sprites.Flag.Ghost));\n\n        if (colliders.length < 10) {\n            // not enough sprite, just brute force it\n            this.map = undefined;\n        } else {\n            if (!this.map) this.map = new sprites.SpriteMap();\n            this.map.update(colliders);\n        }\n\n        // 2: go through sprite and handle collisions\n        const scene = game.currentScene();\n        const tm = scene.tileMap;\n\n        for (const sprite of colliders) {\n            const overSprites = scene.physicsEngine.overlaps(sprite);\n            for (const overlapper of overSprites) {\n                // Maintaining invariant that the sprite with the higher ID has the other sprite as an overlapper\n                const higher = sprite.id > overlapper.id ? sprite : overlapper;\n                const lower = higher === sprite ? overlapper : sprite;\n\n                if (higher._overlappers.indexOf(lower.id) === -1) {\n                    if (sprite.overlapHandler) {\n                        higher._overlappers.push(lower.id);\n                        control.runInParallel(() => {\n                            sprite.overlapHandler(overlapper);\n                            higher._overlappers.removeElement(lower.id);\n                        });\n                    }\n\n                    scene.overlapHandlers\n                        .filter(h => h.kind == sprite.kind() && h.otherKind == overlapper.kind())\n                        .forEach(h => {\n                            higher._overlappers.push(lower.id);\n                            control.runInParallel(() => {\n                                h.handler(sprite, overlapper);\n                                higher._overlappers.removeElement(lower.id);\n                            });\n                        });\n                }\n            }\n\n            sprite.clearObstacles();\n\n            if (tm && tm.enabled) {\n                const xDiff = Fx.sub(sprite._x, sprite._lastX);\n                const yDiff = Fx.sub(sprite._y, sprite._lastY);\n\n                let hitWall = false;\n                const bounce = sprite.flags & sprites.Flag.BounceOnWall;\n\n                if (xDiff !== Fx.zeroFx8) {\n                    const right = xDiff > Fx.zeroFx8;\n                    const x0 = Fx.toIntShifted(Fx.add(right ? Fx.iadd(1, sprite._hitbox.right) : sprite._hitbox.left, Fx8(0.5)), 4);\n                    for (let y = Fx.sub(sprite._hitbox.top, yDiff); y < Fx.iadd(16, Fx.sub(sprite._hitbox.bottom, yDiff)); y = Fx.iadd(16, y)) {\n                        const y0 = Fx.toIntShifted(Fx.add(Fx.min(y, Fx.sub(sprite._hitbox.bottom, yDiff)), Fx8(0.5)), 4);\n                        if (tm.isObstacle(x0, y0)) {\n                            hitWall = true;\n                            if (bounce) {\n                                sprite._vx = Fx.neg(sprite._vx);\n                            }\n                            sprite._x = Fx.iadd(-sprite._hitbox.ox, right ? Fx.sub(Fx8(x0 << 4), Fx8(sprite._hitbox.width)) : Fx8((x0 + 1) << 4));\n                            sprite.registerObstacle(right ? CollisionDirection.Right : CollisionDirection.Left, tm.getObstacle(x0, y0));\n                            break;\n                        }\n                    }\n                }\n                if (yDiff !== Fx.zeroFx8) {\n                    const down = yDiff > Fx.zeroFx8;\n                    const y0 = Fx.toIntShifted(Fx.add(down ? Fx.iadd(1, sprite._hitbox.bottom) : sprite._hitbox.top, Fx8(0.5)), 4);\n                    for (let x = sprite._hitbox.left; x < Fx.iadd(16, sprite._hitbox.right); x = Fx.iadd(16, x)) {\n                        const x0 = Fx.toIntShifted(Fx.add(Fx.min(x, sprite._hitbox.right), Fx8(0.5)), 4);\n                        if (tm.isObstacle(x0, y0)) {\n                            hitWall = true;\n                            if (bounce) {\n                                sprite._vy = Fx.neg(sprite._vy);\n                            }\n                            sprite._y = Fx.iadd(-sprite._hitbox.oy, down ? Fx.sub(Fx8(y0 << 4), Fx8(sprite._hitbox.height)) : Fx8((y0 + 1) << 4));\n                            sprite.registerObstacle(down ? CollisionDirection.Bottom : CollisionDirection.Top, tm.getObstacle(x0, y0));\n                            break;\n                        }\n                    }\n                }\n                if (hitWall && (sprite.flags & sprites.Flag.DestroyOnWall)) {\n                    sprite.destroy();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns sprites that overlap with the given sprite. If type is non-zero, also filter by type.\n     * @param sprite\n     * @param layer\n     */\n    overlaps(sprite: Sprite): Sprite[] {\n        if (this.map)\n            return this.map.overlaps(sprite);\n        else {\n            // brute force\n            const layer = sprite.layer;\n            const r: Sprite[] = [];\n            const n = this.sprites.length;\n            for (let i = 0; i < n; ++i) {\n                if ((layer & this.sprites[i].layer)\n                    && sprite.overlapsWith(this.sprites[i]))\n                    r.push(this.sprites[i]);\n            }\n            return r;\n        }\n    }\n\n    public moveSprite(s: Sprite, tm: tiles.TileMap, dx: Fx8, dy: Fx8) {\n        s._lastX = s._x;\n        s._lastY = s._y;\n        s._x = Fx.add(s._x, dx);\n        s._y = Fx.add(s._y, dy);\n    }\n}\n\nfunction constrain(v: Fx8) {\n    return Fx.max(Fx.min(MAX_VELOCITY, v), NEG_MAX_VELOCITY)\n}\n"},{"type":"added","filename":"tilemap.ts","value":"// Add your code here\nnamespace tiles2 {\n    class TileSet {\n        image: Image;\n        obstacle: boolean;\n        constructor(image: Image, collisions: boolean) {\n            this.image = image;\n            this.obstacle = collisions;\n        }\n    }\n\n    /**\n     * A tile in the tilemap\n     **/\n    //% blockNamespace=scene color=\"#401255\" blockGap=8\n    export class Tile {\n        private _row: number;\n        private _col: number;\n        private _map: Image;\n\n        constructor(col: number, row: number, map: Image) {\n            this._col = col;\n            this._row = row;\n            this._map = map;\n        }\n\n        get x(): number {\n            return (this._col << 4) + 8;\n        }\n\n        get y(): number {\n            return (this._row << 4) + 8;\n        }\n\n        get tileSet(): number {\n            return this._map.getPixel(this._col, this._row);\n        }\n\n        /**\n         * Center the given sprite on this tile\n         * @param sprite\n         */\n        //% blockId=gameplaceontile block=\"on top of %tile(myTile) place %sprite=variables_get(mySprite)\"\n        //% blockNamespace=\"scene\" group=\"Tiles\"\n        //% weight=25\n        //% help=scene/place\n        place(mySprite: Sprite): void {\n            if (!mySprite) return;\n\n            mySprite.x = this.x;\n            mySprite.y = this.y;\n        }\n    }\n\n    export class TileMap implements SpriteLike {\n        id: number;\n        z: number;\n\n        private _layer: number;\n\n        private _map: Image;\n        private _tileSets: TileSet[];\n\n        constructor() {\n            this._tileSets = [];\n            this._layer = 1;\n            this.z = -1;\n\n            const sc = game.currentScene();\n            sc.addSprite(this);\n            sc.flags |= scene.Flag.NeedsSorting;\n        }\n\n        offsetX(value: number) {\n            return Math.clamp(0, Math.max(this.areaWidth() - screen.width, 0), value);\n        }\n\n        offsetY(value: number) {\n            return Math.clamp(0, Math.max(this.areaHeight() - screen.height, 0), value);\n        }\n\n        areaWidth() {\n            return this._map ? (this._map.width << 4) : 0;\n        }\n\n        areaHeight() {\n            return this._map ? (this._map.height << 4) : 0;\n        }\n\n        get layer(): number {\n            return this._layer;\n        }\n\n        set layer(value: number) {\n            if (this._layer != value) {\n                this._layer = value;\n            }\n        }\n\n        get enabled(): boolean {\n            return !!this._map;\n        }\n\n        setTile(index: number, img: Image, collisions?: boolean) {\n            if (this.isInvalidIndex(index)) return;\n            this._tileSets[index] = new TileSet(img, collisions);\n        }\n\n        setMap(map: Image) {\n            this._map = map;\n        }\n\n        public getTile(col: number, row: number): Tile {\n            if (this.isOutsideMap(col, row)) return undefined;\n            return new Tile(col, row, this._map);\n        }\n\n        public setTileAt(col: number, row: number, index: number): void {\n            if (!this.isOutsideMap(col, row) && !this.isInvalidIndex(index))\n                this._map.setPixel(col, row, index);\n        }\n\n        public getTilesByType(index: number): Tile[] {\n            if (this.isInvalidIndex(index) || !this.enabled) return undefined;\n\n            let output: Tile[] = [];\n            for (let col = 0; col < this._map.width; ++col) {\n                for (let row = 0; row < this._map.height; ++row) {\n                    let currTile = this._map.getPixel(col, row);\n                    if (currTile === index) {\n                        output.push(new Tile(col, row, this._map));\n                    }\n                }\n            }\n            return output;\n        }\n\n        __serialize(offset: number): Buffer { return undefined; }\n\n        __update(camera: scene.Camera, dt: number): void { }\n\n        /**\n         * Draws all visible\n         */\n        __draw(camera: scene.Camera): void {\n            if (!this.enabled) return;\n\n            const offsetX = camera.drawOffsetX & 0xf;\n            const offsetY = camera.drawOffsetY & 0xf;\n            const x0 = Math.max(0, camera.drawOffsetX >> 4);\n            const xn = Math.min(this._map.width, ((camera.drawOffsetX + screen.width) >> 4) + 1);\n            const y0 = Math.max(0, camera.drawOffsetY >> 4);\n            const yn = Math.min(this._map.height, ((camera.drawOffsetY + screen.height) >> 4) + 1);\n\n            for (let x = x0; x <= xn; ++x) {\n                for (let y = y0; y <= yn; ++y) {\n                    const index = this._map.getPixel(x, y);\n                    const tile = this._tileSets[index] || this.generateTile(index);\n                    if (tile) {\n                        screen.drawTransparentImage(tile.image, ((x - x0) << 4) - offsetX, ((y - y0) << 4) - offsetY)\n                    }\n                }\n            }\n        }\n\n        private generateTile(index: number): TileSet {\n            if (index == 0) return undefined;\n\n            const img = image.create(16, 16);\n            img.fill(index);\n            return this._tileSets[index] = new TileSet(img, false);\n        }\n\n        private isOutsideMap(col: number, row: number): boolean {\n            return !this.enabled || col < 0 || col >= this._map.width\n                || row < 0 || row >= this._map.height;\n        }\n\n        private isInvalidIndex(index: number): boolean {\n            return index < 0 || index > 0xf;\n        }\n\n        draw(camera: scene.Camera) {\n            if (!this.enabled) return;\n\n            if (game.debug) {\n                const offsetX = -camera.drawOffsetX;\n                const offsetY = -camera.drawOffsetY;\n                const x0 = Math.max(0, -(offsetX >> 4));\n                const xn = Math.min(this._map.width, (-offsetX + screen.width) >> 4);\n                const y0 = Math.max(0, -(offsetY >> 4));\n                const yn = Math.min(this._map.height, (-offsetY + screen.height) >> 4);\n                for (let x = x0; x <= xn; ++x) {\n                    screen.drawLine(\n                        (x << 4) + offsetX,\n                        offsetY,\n                        (x << 4) + offsetX,\n                        (this._map.height << 4) + offsetY, 1)\n                }\n                for (let y = y0; y <= yn; ++y) {\n                    screen.drawLine(\n                        offsetX,\n                        (y << 4) + offsetY,\n                        (this._map.width << 4) + offsetX,\n                        (y << 4) + offsetY,\n                        1)\n                }\n            }\n        }\n\n        public update(camera: scene.Camera) {\n        }\n\n        public collisions(s: Sprite): sprites.Obstacle[] {\n            let overlappers: sprites.StaticObstacle[] = [];\n\n            if (this.enabled && (s.layer & this.layer) && !(s.flags & sprites.Flag.Ghost)) {\n                const x0 = Math.max(0, s.left >> 4);\n                const xn = Math.min(this._map.width, (s.right >> 4) + 1);\n                const y0 = Math.max(0, s.top >> 4);\n                const yn = Math.min(this._map.height, (s.bottom >> 4) + 1);\n\n                // let res = `x: ${x0}-${xn} y: ${y0}-${yn} HIT:`;\n                for (let x = x0; x <= xn; ++x) {\n                    const left = x << 4;\n                    for (let y = y0; y <= yn; ++y) {\n                        const index = this._map.getPixel(x, y);\n                        const tile = this._tileSets[index] || this.generateTile(index);\n                        if (tile && tile.obstacle) {\n                            const top = y << 4;\n                            if (tile.image.overlapsWith(s.image, s.left - left, s.top - top)) {\n                                overlappers.push(new sprites.StaticObstacle(tile.image, top, left, this.layer, index));\n                            }\n                        }\n                    }\n                }\n            }\n\n            return overlappers;\n        }\n\n        public isObstacle(col: number, row: number) {\n            if (!this.enabled) return false;\n            if (this.isOutsideMap(col, row)) return true;\n\n            let t = this._tileSets[this._map.getPixel(col, row)];\n            return t && t.obstacle;\n        }\n\n        public getObstacle(col: number, row: number) {\n            if (!this.enabled) return undefined;\n            if (this.isOutsideMap(col, row)) return undefined;\n\n            const index = this._map.getPixel(col, row);\n            const tile = this._tileSets[index] || this.generateTile(index);\n            if (tile.obstacle) {\n                return new sprites.StaticObstacle(tile.image, row << 4, col << 4, this.layer, index);\n            }\n            return undefined;\n        }\n    }\n}\n"},{"type":"added","filename":"scene.ts","value":"// Add your code here\n/**\n * Control the background, tiles and camera\n */\nnamespace scene2 {\n    export enum Flag {\n        NeedsSorting = 1 << 1,\n    }\n\n    export interface SpriteHandler {\n        kind: number;\n        handler: (sprite: Sprite2) => void;\n    }\n\n    export interface OverlapHandler {\n        kind: number;\n        otherKind: number;\n        handler: (sprite2: Sprite, otherSprite: Sprite2) => void;\n    }\n\n    export interface CollisionHandler {\n        kind: number;\n        tile: number;\n        handler: (sprite: Sprite2) => void\n    }\n\n    export class Scene {\n        eventContext: control.EventContext;\n        background: Background;\n        tileMap: tiles.TileMap;\n        allSprites: SpriteLike[];\n        private spriteNextId: number;\n        spritesByKind: SpriteSet[];\n        physicsEngine: PhysicsEngine;\n        camera: scene.Camera;\n        flags: number;\n        destroyedHandlers: SpriteHandler[];\n        createdHandlers: SpriteHandler[];\n        overlapHandlers: OverlapHandler[];\n        collisionHandlers: CollisionHandler[];\n        private _millis: number;\n        private _data: any;\n\n        constructor(eventContext: control.EventContext) {\n            this.eventContext = eventContext;\n            this.flags = 0;\n            this.physicsEngine = new ArcadePhysicsEngine();\n            this.camera = new scene.Camera();\n            this.background = new Background(this.camera);\n            this.destroyedHandlers = [];\n            this.createdHandlers = [];\n            this.overlapHandlers = [];\n            this.collisionHandlers = [];\n            this.spritesByKind = [];\n            this._data = {};\n            this._millis = 0;\n        }\n\n        init() {\n            if (this.allSprites) return;\n\n            this.allSprites = [];\n            this.spriteNextId = 0;\n            // update controller state\n            this.eventContext.registerFrameHandler(8, () => {\n                this._millis += this.eventContext.deltaTimeMillis;\n                control.enablePerfCounter(\"controller_update\")\n                controller.__update(this.eventContext.deltaTime);\n            })\n            // update sprites in tilemap\n            this.eventContext.registerFrameHandler(9, () => {\n                control.enablePerfCounter(\"tilemap_update\")\n                if (this.tileMap) {\n                    this.tileMap.update(this.camera);\n                }\n            })\n            // apply physics 10\n            this.eventContext.registerFrameHandler(10, () => {\n                control.enablePerfCounter(\"physics\")\n                const dt = this.eventContext.deltaTime;\n                this.physicsEngine.move(dt);\n            })\n            // user update 20\n            // apply collisions 30\n            this.eventContext.registerFrameHandler(30, () => {\n                control.enablePerfCounter(\"collisions\")\n                const dt = this.eventContext.deltaTime;\n                this.physicsEngine.collisions();\n                this.camera.update();\n                for (const s of this.allSprites)\n                    s.__update(this.camera, dt);\n            })\n            // render background 60\n            this.eventContext.registerFrameHandler(60, () => {\n                control.enablePerfCounter(\"render background\")\n                this.background.draw();\n            })\n            // paint 75\n            // render sprites 90\n            this.eventContext.registerFrameHandler(90, () => {\n                control.enablePerfCounter(\"sprite_draw\")\n                if (this.flags & Flag.NeedsSorting)\n                    this.allSprites.sort(function (a, b) { return a.z - b.z || a.id - b.id; })\n                for (const s of this.allSprites)\n                    s.__draw(this.camera);\n            })\n            // render diagnostics\n            this.eventContext.registerFrameHandler(150, () => {\n                if (game.stats && control.EventContext.onStats) {\n                    control.EventContext.onStats(\n                        control.EventContext.lastStats +\n                        ` sprites:${this.allSprites.length}`\n                    )\n                }\n                if (game.debug)\n                    this.physicsEngine.draw();\n                game.consoleOverlay.draw();\n                // clear flags\n                this.flags = 0;\n            });\n            // update screen\n            this.eventContext.registerFrameHandler(200, control.__screen.update);\n            // register start menu\n            scene.systemMenu.register();\n        }\n\n        get data() {\n            return this._data;\n        }\n\n        /**\n         * Gets the elapsed time in the scene\n         */\n        millis(): number {\n            return this._millis;\n        }\n\n        addSprite(sprite: SpriteLike) {\n            this.allSprites.push(sprite);\n            sprite.id = this.spriteNextId++;\n        }\n\n        destroy() {\n            this.eventContext = undefined;\n            this.menuState = undefined;\n            this.background = undefined;\n            this.tileMap = undefined;\n            this.allSprites = undefined;\n            this.spriteNextId = undefined;\n            this.spritesByKind = undefined;\n            this.physicsEngine = undefined;\n            this.camera = undefined;\n            this.flags = undefined;\n            this.destroyedHandlers = undefined;\n            this.createdHandlers = undefined;\n            this.overlapHandlers = undefined;\n            this.collisionHandlers = undefined;\n            this._data = undefined;\n        }\n    }\n}\n"},{"type":"added","filename":"game.ts","value":"// Add your code here\n/**\n * Game transitions and dialog\n **/\n//% color=#008272 weight=97 icon=\"\\uf111\"\n//% groups='[\"Gameplay\", \"Prompt\"]'\nnamespace game {\n    /**\n     * Determines if diagnostics are shown\n     */\n    export let debug = false;\n    export let stats = false;\n    export let winEffect: effects.BackgroundEffect = undefined;\n    export let loseEffect: effects.BackgroundEffect = undefined;\n    let loseSound: music.Melody = undefined;\n    let winSound: music.Melody = undefined;\n\n    let _scene: scene.Scene;\n    let _sceneStack: scene.Scene[];\n\n    export function currentScene(): scene.Scene {\n        init();\n        return _scene;\n    }\n\n    let __waitAnyButton: () => void\n    let __isOver = false;\n\n    export function setWaitAnyButton(f: () => void) {\n        __waitAnyButton = f\n    }\n\n    export function waitAnyButton() {\n        if (__waitAnyButton) __waitAnyButton()\n        else pause(3000)\n    }\n\n    export function eventContext(): control.EventContext {\n        init();\n        return _scene.eventContext;\n    }\n\n    function init() {\n        if (!_scene) _scene = new scene.Scene(control.pushEventContext());\n        _scene.init();\n\n        if (!winEffect)\n            winEffect = effects.confetti;\n        if (!loseEffect)\n            loseEffect = effects.melt;\n\n        if (!winSound)\n            winSound = music.powerUp;\n        if (!loseSound)\n            loseSound = music.wawawawaa;\n    }\n\n    export function pushScene() {\n        init();\n        particles.clearAll();\n        particles.disableAll();\n        if (!_sceneStack) _sceneStack = [];\n        _sceneStack.push(_scene);\n        _scene = undefined;\n        init();\n    }\n\n    export function popScene() {\n        if (_sceneStack && _sceneStack.length) {\n            // pop scenes from the stack\n            _scene = _sceneStack.pop();\n            control.popEventContext();\n        } else if (_scene) {\n            // post last scene\n            control.popEventContext();\n            _scene = undefined;\n        }\n        if (_scene)\n            particles.enableAll();\n    }\n\n    function showDialogBackground(h: number, c: number) {\n        const top = (screen.height - h) >> 1;\n        screen.fillRect(0, top, screen.width, h, 0)\n        screen.drawLine(0, top, screen.width, top, 1)\n        screen.drawLine(0, top + h - 1, screen.width, top + h - 1, 1)\n\n        return top;\n    }\n\n    export function showDialog(title: string, subtitle: string, footer?: string) {\n        init();\n        const font = image.font8;\n        let h = 8;\n        if (title)\n            h += font.charHeight;\n        if (subtitle)\n            h += 2 + font.charHeight\n        h += 8;\n        const top = showDialogBackground(h, 9)\n        if (title)\n            screen.print(title, 8, top + 8, screen.isMono ? 1 : 7, font);\n        if (subtitle)\n            screen.print(subtitle, 8, top + 8 + font.charHeight + 2, screen.isMono ? 1 : 6, font);\n        if (footer) {\n            screen.print(\n                footer,\n                screen.width - footer.length * font.charWidth - 8,\n                screen.height - font.charHeight - 2,\n                1,\n                font\n            )\n        }\n    }\n\n    /**\n     * Set the effect that occurs when the game is over\n     * @param win whether the animation should run on a win (true)\n     * @param effect\n     */\n    export function setGameOverEffect(win: boolean, effect: effects.BackgroundEffect) {\n        init();\n        if (!effect) return;\n        if (win)\n            winEffect = effect;\n        else\n            loseEffect = effect;\n    }\n\n    /**\n     * Set the music that occurs when the player wins\n     * @param win\n     * @param effect\n     */\n    export function setGameOverSound(win: boolean, sound: music.Melody) {\n        init();\n        if (!sound) return;\n        if (win)\n            winSound = sound;\n        else\n            loseSound = sound;\n    }\n\n    /**\n     * Finish the game and display the score\n     */\n    //% group=\"Gameplay\"\n    //% blockId=gameOver block=\"game over || %win=toggleWinLose with %effect effect\"\n    //% weight=80 help=game/over\n    export function over(win: boolean = false, effect?: effects.BackgroundEffect) {\n        init();\n        if (__isOver) return;\n        __isOver = true;\n\n        if (!effect) {\n            effect = win ? winEffect : loseEffect;\n        }\n\n        // one last screenshot\n        takeScreenshot();\n\n        // releasing memory and clear fibers. Do not add anything that releases the fiber until background is set below,\n        // or screen will be cleared on the new frame and will not appear as background in the game over screen.\n        while (_sceneStack && _sceneStack.length) {\n            _scene.destroy();\n            popScene();\n        }\n        pushScene();\n        scene.setBackgroundImage(screen.clone());\n\n        if (win)\n            winSound.play();\n        else\n            loseSound.play();\n\n        effect.startScreenEffect();\n\n        pause(500);\n\n        game.eventContext().registerFrameHandler(95, () => {\n            let top = showDialogBackground(46, 4);\n            screen.printCenter(win ? \"YOU WIN!\" : \"GAME OVER!\", top + 8, screen.isMono ? 1 : 5, image.font8);\n            if (info.hasScore()) {\n                screen.printCenter(\"Score:\" + info.score(), top + 23, screen.isMono ? 1 : 2, image.font8);\n                if (info.score() > info.highScore()) {\n                    info.saveHighScore();\n                    screen.printCenter(\"New High Score!\", top + 34, screen.isMono ? 1 : 2, image.font5);\n                } else {\n                    screen.printCenter(\"HI\" + info.highScore(), top + 34, screen.isMono ? 1 : 2, image.font8);\n                }\n            }\n        });\n\n        pause(2000); // wait for users to stop pressing keys\n        waitAnyButton();\n        control.reset();\n    }\n\n    /**\n     * Tells the game host to grab a screenshot\n     */\n    //% shim=game::takeScreenshot\n    declare function takeScreenshot(): void;\n\n    /**\n     * Update the position and velocities of sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update weight=100 afterOnStart=true\n    //% blockId=gameupdate block=\"on game update\"\n    //% blockAllowMultiple=1\n    export function onUpdate(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(20, a);\n    }\n\n    /**\n     * Run code on an interval of time. This executes before game.onUpdate()\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update-interval weight=99 afterOnStart=true\n    //% blockId=gameinterval block=\"on game update every %period=timePicker ms\"\n    //% blockAllowMultiple=1\n    export function onUpdateInterval(period: number, a: () => void): void {\n        init();\n        if (!a || period < 0) return;\n        let timer = 0;\n        game.eventContext().registerFrameHandler(19, () => {\n            const time = game.currentScene().millis();\n            if (timer <= time) {\n                timer = time + period;\n                a();\n            }\n        });\n    }\n\n    /**\n     * Draw on screen before sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/paint weight=10 afterOnStart=true\n    export function onPaint(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(75, a);\n    }\n\n    /**\n     * Returns the time since the game started in milliseconds\n     */\n    //% blockId=arcade_game_runtime block=\"time since start (ms)\"\n    //% group=\"Gameplay\" weight=11\n    //% help=game/runtime\n    export function runtime(): number {\n        return currentScene().millis();\n    }\n}\n"},{"type":"added","filename":"spritemap.ts","value":"// Add your code here\nnamespace sprites2 {\n    export class SpriteMap {\n        private cellWidth: number;\n        private cellHeight: number;\n        private rowCount: number;\n        private columnCount: number;\n        private buckets: Sprite[][];\n\n        constructor() {\n            this.buckets = [];\n        }\n\n        /**\n         * Returns a potential list of neighbors\n         */\n        neighbors(sprite: Sprite2): Sprite2[] {\n            if (this.isOob(sprite)) return [];\n\n            const n: Sprite2[] = [];\n            const layer = sprite.layer;\n            this.mergeAtKey(sprite.left, sprite.top, layer, n)\n            this.mergeAtKey(sprite.left, sprite.bottom, layer, n)\n            this.mergeAtKey(sprite.right, sprite.top, layer, n)\n            this.mergeAtKey(sprite.right, sprite.bottom, layer, n)\n            n.removeElement(sprite);\n            return n;\n        }\n\n        /**\n         * Gets the overlaping sprites if any\n         * @param sprite\n         */\n        overlaps(sprite: Sprite): Sprite[] {\n            const n = this.neighbors(sprite);\n            const o = n.filter(neighbor => sprite.overlapsWith(neighbor));\n            return o;\n        }\n\n        draw() {\n            for (let x = 0; x < this.columnCount; ++x) {\n                for (let y = 0; y < this.rowCount; ++y) {\n                    const left = x * this.cellWidth;\n                    const top = y * this.cellHeight;\n                    const k = this.key(left, top);\n                    const b = this.buckets[k];\n                    if (b && b.length)\n                        screen.drawRect(left, top, this.cellWidth, this.cellHeight, 5);\n                }\n            }\n        }\n\n        /**\n         * Recompute hashes for all objects\n         */\n        update(sprites: Sprite[]) {\n            this.buckets = [];\n\n            // rescale buckets\n            let maxWidth = 0;\n            let maxHeight = 0;\n            for (const sprite of sprites) {\n                if (sprite.width > maxWidth) maxWidth = sprite.width;\n                if (sprite.height > maxHeight) maxHeight = sprite.height;\n            }\n\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n\n            this.cellWidth = Math.clamp(8, areaWidth >> 2, maxWidth * 2);\n            this.cellHeight = Math.clamp(8, areaHeight >> 2, maxHeight * 2);\n            this.rowCount = Math.idiv(areaHeight, this.cellHeight)\n            this.columnCount = Math.idiv(areaWidth, this.cellWidth)\n\n\n            for (const sprite of sprites)\n                this.insertAABB(sprite);\n        }\n\n        private key(x: number, y: number): number {\n            const xi = Math.clamp(0, this.columnCount, Math.idiv(x, this.cellWidth));\n            const yi = Math.clamp(0, this.rowCount, Math.idiv(y, this.cellHeight));\n            return xi + yi * this.columnCount;\n        }\n\n        private insertAtKey(x: number, y: number, sprite: Sprite) {\n            const k = this.key(x, y);\n            let bucket = this.buckets[k];\n            if (!bucket)\n                bucket = this.buckets[k] = [];\n            if (bucket.indexOf(sprite) < 0)\n                bucket.push(sprite);\n        }\n\n        private isOob(sprite: Sprite): boolean {\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n            return sprite.right < 0 || sprite.left > areaWidth || sprite.bottom < 0 || sprite.top > areaHeight;\n        }\n\n        private insertAABB(sprite: Sprite) {\n            // is object completely out of space?\n            if (this.isOob(sprite) || (sprite.flags & sprites.Flag.Ghost))\n                return;\n\n            const left = sprite.left;\n            const top = sprite.top;\n            const xn = Math.idiv(sprite.width + this.cellWidth - 1, this.cellWidth);\n            const yn = Math.idiv(sprite.height + this.cellHeight - 1, this.cellHeight);\n            for (let x = 0; x <= xn; x++)\n                for (let y = 0; y <= yn; y++)\n                    this.insertAtKey(left + Math.min(sprite.width, x * this.cellWidth), top + Math.min(sprite.height, y * this.cellHeight), sprite)\n        }\n\n        private mergeAtKey(x: number, y: number, layer: number, n: Sprite2[]) {\n            const k = this.key(x, y);\n            const bucket = this.buckets[k];\n            if (bucket) {\n                for (const sprite of bucket)\n                    if ((sprite.layer & layer)\n                        && n.indexOf(sprite) < 0)\n                        n.push(sprite);\n            }\n        }\n\n        toString() {\n            return `${this.buckets.length} buckets, ${this.buckets.filter(b => !!b).length} filled`;\n        }\n    }\n}"},{"type":"added","filename":"spriteset.ts","value":"/* \n* A set of sprites \n*/\nclass SpriteSet2 {\n    private _sprites: Sprite2[];\n\n    /**\n     * Create a new set from an array of sprites\n     * @param sprites \n     */\n    static createFromArray(sprites: Sprite2[]): SpriteSet2 {\n        const sp = new SpriteSet2();\n        const n = sprites.length;\n        for (let i = 0; i < n; ++i)\n            sp.add(sprites[i]);\n        return sp;\n    }\n\n    constructor() {\n        this._sprites = [];\n    }\n\n    /**\n     * Gets the number of sprites in the set\n     */\n    get length() {\n        return this._sprites.length;\n    }\n\n    /**\n     * Gets the snapshot of the current list of sprites\n     */\n    sprites() {\n        return this._sprites.slice(0, this._sprites.length);\n    }\n\n    /**\n     * Adds the sprite, returns true if added; false if the sprite was already in the set\n     * @param sprite \n     */\n    add(sprite: Sprite2): boolean {\n        if (!sprite) return false; // don't add nulls\n\n        // scan if in set\n        if (this.contains(sprite))\n            return false;\n        this._sprites.push(sprite);\n        return true;\n    }\n\n    /**\n     * Adds sprite and removes from old set. Returns true if sprite was in old set and not in new set.\n     * @param oldSet \n     * @param sprite \n     */\n    addFrom(oldSet: SpriteSet2, sprite: Sprite2): boolean {\n        const removed = oldSet.remove(sprite);\n        const added = this.add(sprite);\n        return removed && added;\n    }\n\n    /**\n     * Removes sprite from set. Returns true if the sprite was in the set\n     * @param sprite \n     */\n    remove(sprite: Sprite2): boolean {\n        const i = this._sprites.indexOf(sprite);\n        if (i > -1) {\n            this._sprites.splice(i, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the sprite is part of the set\n     * @param sprite \n     */\n    contains(sprite: Sprite2): boolean {\n        return this._sprites.indexOf(sprite) > -1;\n    }\n\n    /** \n     * Removes all the sprites from the set\n    */\n    clear() {\n        this._sprites.splice(0, this._sprites.length);\n    }\n\n    /**\n     * Removes the last sprite in the set\n     */\n    pop(): Sprite2 {\n        return this._sprites.pop();\n    }\n\n    toString() {\n        return `${this.length} sprites`\n    }\n}"}]},{"timestamp":1756165856670,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"sprite.ts","patch":[{"start1":4048,"length1":46,"diffs":[[1,"    overlapHandler: (other: Sprite) => void;\n"]]}]},{"type":"edited","filename":"physics.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"// Add your code here\n"]]},{"start1":560,"length1":59,"diffs":[[1,"const MAX_VELOCITY = Fx.div(MAX_DISTANCE, MAX_TIME_STEP);\n"]]},{"start1":756,"length1":125,"diffs":[[1,"class ArcadePhysicsEngine extends PhysicsEngine {\n    protected sprites: Sprite[];\n    protected map: sprites.SpriteMap;\n"]]},{"start1":949,"length1":33,"diffs":[[1,"    addSprite(sprite: Sprite) {\n"]]},{"start1":1023,"length1":36,"diffs":[[1,"    removeSprite(sprite: Sprite) {\n"]]},{"start1":1203,"length1":52,"diffs":[[1,"        const dtf = Fx.min(MAX_TIME_STEP, Fx8(dt))\n"]]},{"start1":1291,"length1":49,"diffs":[[1,"        const tm = game.currentScene().tileMap;\n"]]},{"start1":1863,"length1":96,"diffs":[[1,"        const colliders = this.sprites.filter(sprite => !(sprite.flags & sprites.Flag.Ghost));\n"]]},{"start1":2101,"length1":64,"diffs":[[1,"            if (!this.map) this.map = new sprites.SpriteMap();\n"]]},{"start1":2269,"length1":44,"diffs":[[1,"        const scene = game.currentScene();\n"]]},{"start1":2511,"length1":0,"diffs":[[1,"                // Maintaining invariant that the sprite with the higher ID has the other sprite as an overlapper\n"]]},{"start1":6552,"length1":43,"diffs":[[1,"    overlaps(sprite: Sprite): Sprite[] {\n"]]},{"start1":6676,"length1":0,"diffs":[[1,"            // brute force\n"]]},{"start1":6743,"length1":37,"diffs":[[1,"            const r: Sprite[] = [];\n"]]},{"start1":7075,"length1":74,"diffs":[[1,"    public moveSprite(s: Sprite, tm: tiles.TileMap, dx: Fx8, dy: Fx8) {\n"]]},{"start1":7364,"length1":1,"diffs":[[1,""]]}]},{"type":"edited","filename":"scene.ts","patch":[{"start1":351,"length1":67,"diffs":[[1,"        handler: (sprite2: Sprite, otherSprite: Sprite2) => void;\n"]]},{"start1":627,"length1":71,"diffs":[[1,"        background: Background;\n        tileMap: tiles.TileMap;\n"]]},{"start1":763,"length1":76,"diffs":[[1,"        spritesByKind: SpriteSet[];\n        physicsEngine: PhysicsEngine;\n"]]},{"start1":1260,"length1":61,"diffs":[[1,"            this.physicsEngine = new ArcadePhysicsEngine();\n"]]},{"start1":1366,"length1":65,"diffs":[[1,"            this.background = new Background(this.camera);\n"]]},{"start1":4746,"length1":41,"diffs":[[1,"        addSprite(sprite: SpriteLike) {\n"]]},{"start1":4947,"length1":0,"diffs":[[1,"            this.menuState = undefined;\n"]]}]},{"type":"edited","filename":"game.ts","patch":[{"start1":140,"length1":18,"diffs":[[1,"namespace game {\n"]]},{"start1":495,"length1":67,"diffs":[[1,"    let _scene: scene.Scene;\n    let _sceneStack: scene.Scene[];\n"]]},{"start1":561,"length1":51,"diffs":[[1,"    export function currentScene(): scene.Scene {\n"]]},{"start1":1066,"length1":76,"diffs":[[1,"        if (!_scene) _scene = new scene.Scene(control.pushEventContext());\n"]]}]},{"type":"edited","filename":"spritemap.ts","patch":[{"start1":989,"length1":47,"diffs":[[1,"        overlaps(sprite: Sprite): Sprite[] {\n"]]},{"start1":1762,"length1":37,"diffs":[[1,"        update(sprites: Sprite[]) {\n"]]},{"start1":2986,"length1":69,"diffs":[[1,"        private insertAtKey(x: number, y: number, sprite: Sprite) {\n"]]},{"start1":3298,"length1":50,"diffs":[[1,"        private isOob(sprite: Sprite): boolean {\n"]]},{"start1":3668,"length1":46,"diffs":[[1,"        private insertAABB(sprite: Sprite) {\n"]]}]}]},{"timestamp":1756166415386,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":346,"length1":44,"diffs":[[1,"        \"spriteset.ts\"\n"]]}]},{"type":"edited","filename":"sprite.ts","patch":[{"start1":0,"length1":20,"diffs":[[1,"enum SpriteFlag2 {\n"]]},{"start1":3809,"length1":45,"diffs":[[1,"    private _obstacles: sprites.Obstacle[];\n"]]},{"start1":3921,"length1":38,"diffs":[[1,"    private sayBubbleSprite: Sprite;\n"]]},{"start1":3959,"length1":27,"diffs":[[1,"    _hitbox: game.Hitbox;\n"]]},{"start1":6221,"length1":52,"diffs":[[1,"        this._hitbox = game.calculateHitBox(this);\n"]]},{"start1":9568,"length1":66,"diffs":[[1,"        const spritesByKind = game.currentScene().spritesByKind;\n"]]},{"start1":9770,"length1":80,"diffs":[[1,"            if (!spritesByKind[value]) spritesByKind[value] = new SpriteSet();\n"]]},{"start1":12991,"length1":112,"diffs":[[1,"        this.sayBubbleSprite = sprites.create(image.create(bubbleWidth, font.charHeight + bubblePadding), -1);\n"]]},{"start1":13103,"length1":63,"diffs":[[1,"        this.sayBubbleSprite.setFlag(SpriteFlag.Ghost, true);\n"]]},{"start1":17566,"length1":52,"diffs":[[1,"        if (this.flags & SpriteFlag.ShowPhysics) {\n"]]},{"start1":18711,"length1":53,"diffs":[[1,"        if ((this.flags & sprites.Flag.AutoDestroy)\n"]]},{"start1":18846,"length1":64,"diffs":[[1,"        const bounce = this.flags & sprites.Flag.BounceOnWall;\n"]]},{"start1":18957,"length1":74,"diffs":[[1,"        if (this.flags & sprites.Flag.StayInScreen || (bounce && !tm)) {\n"]]},{"start1":20001,"length1":43,"diffs":[[1,"    //% flag.defl=SpriteFlag.StayInScreen\n"]]},{"start1":20080,"length1":46,"diffs":[[1,"    setFlag(flag: SpriteFlag, on: boolean) {\n"]]},{"start1":20498,"length1":35,"diffs":[[1,"    overlapsWith(other: Sprite) {\n"]]},{"start1":20622,"length1":46,"diffs":[[1,"        if (this.flags & sprites.Flag.Ghost)\n"]]},{"start1":20692,"length1":47,"diffs":[[1,"        if (other.flags & sprites.Flag.Ghost)\n"]]},{"start1":21111,"length1":51,"diffs":[[1,"    onOverlap(handler: (other: Sprite) => void) {\n"]]},{"start1":22707,"length1":80,"diffs":[[1,"    registerObstacle(direction: CollisionDirection, other: sprites.Obstacle) {\n"]]},{"start1":23119,"length1":44,"diffs":[[1,"        const scene = game.currentScene();\n"]]},{"start1":23786,"length1":50,"diffs":[[1,"        if (this.flags & sprites.Flag.Destroyed)\n"]]},{"start1":23878,"length1":37,"diffs":[[1,"            effect.destroy(this);\n"]]},{"start1":23943,"length1":90,"diffs":[[1,"        this.flags |= sprites.Flag.Destroyed\n        const scene = game.currentScene();\n"]]},{"start1":24718,"length1":1332,"diffs":[[1,""]]}]},{"type":"added","filename":"hitbox.ts","value":"// Add your code here\nnamespace game2 {\n    export class Hitbox {\n        parent: Sprite2;\n        ox: number;\n        oy: number;\n        width: number;\n        height: number;\n\n        constructor(parent: Sprite2, width: number, height: number, ox: number, oy: number) {\n            this.width = width;\n            this.height = height;\n            this.parent = parent;\n            this.ox = ox;\n            this.oy = oy;\n        }\n\n        get left() {\n            return Fx.iadd(this.ox, this.parent._x)\n        }\n\n        get top() {\n            return Fx.iadd(this.oy, this.parent._y)\n        }\n\n        get right() {\n            return Fx.iadd(this.width - 1, this.left)\n        }\n\n        get bottom() {\n            return Fx.iadd(this.height - 1, this.top)\n        }\n    }\n\n\n    export function calculateHitBox(s: Sprite2): Hitbox {\n        const i = s.image;\n        let minX = i.width;\n        let minY = i.height;\n        let maxX = 0;\n        let maxY = 0;\n\n        for (let c = 0; c < i.width; c++) {\n            for (let r = 0; r < i.height; r++) {\n                if (i.getPixel(c, r)) {\n                    minX = Math.min(minX, c);\n                    minY = Math.min(minY, r);\n                    maxX = Math.max(maxX, c);\n                    maxY = Math.max(maxY, r);\n                }\n            }\n        }\n\n        const width = maxX - minX + 1;\n        const height = maxY - minY + 1;\n\n        return new Hitbox(s, width, height, minX, minY);\n    }\n}"}]},{"timestamp":1756167006936,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":41,"diffs":[[1,"    \"name\": \"fix\",\n"]]}]},{"type":"edited","filename":"sprite.ts","patch":[{"start1":0,"length1":19,"diffs":[[1,"enum SpriteFlag22 {\n"]]},{"start1":42,"length1":15,"diffs":[[1,"    Ghost = sprites2.Flag.Ghost,\n"]]},{"start1":104,"length1":21,"diffs":[[1,"    AutoDestroy = sprites2.Flag.AutoDestroy,\n"]]},{"start1":180,"length1":22,"diffs":[[1,"    StayInScreen = sprites2.Flag.StayInScreen,\n"]]},{"start1":259,"length1":23,"diffs":[[1,"    DestroyOnWall = sprites2.Flag.DestroyOnWall,\n"]]},{"start1":339,"length1":22,"diffs":[[1,"    BounceOnWall = sprites2.Flag.BounceOnWall,\n"]]},{"start1":415,"length1":20,"diffs":[[1,"    ShowPhysics = sprites2.Flag.ShowPhysics\n"]]},{"start1":7474,"length1":68,"diffs":[[1,"            game.currentScene().flags |= scene.Flag.NeedsSorting;\n"]]},{"start1":12091,"length1":51,"diffs":[[1,"        const currentScene = game.currentScene();\n"]]},{"start1":14591,"length1":71,"diffs":[[1,"                    holdTextSeconds -= game.eventContext().deltaTime;\n"]]},{"start1":18279,"length1":27,"diffs":[[1,"        if (game.debug) {\n"]]},{"start1":18921,"length1":49,"diffs":[[1,"        const tm = game.currentScene().tileMap;\n"]]}]},{"type":"edited","filename":"sprites.ts","patch":[{"start1":490,"length1":96,"diffs":[[1,"    //% blockId=spritescreate block=\"sprite %img=screen_image_picker of kind %kind=spritetype\"\n"]]},{"start1":761,"length1":44,"diffs":[[1,"        const scene = game.currentScene();\n"]]},{"start1":1245,"length1":77,"diffs":[[1,"    //% blockId=allOfKind block=\"array of sprites of kind %kind=spritetype\"\n"]]},{"start1":1402,"length1":123,"diffs":[[1,"    export function allOfKind(kind: number): Sprite[] {\n        const spritesByKind = game.currentScene().spritesByKind;\n"]]},{"start1":1905,"length1":122,"diffs":[[1,"    //% blockId=spritescreateprojectilefromside block=\"projectile %img=screen_image_picker from side with vx %vx vy %vy\"\n"]]},{"start1":2646,"length1":151,"diffs":[[1,"    //% blockId=spritescreateprojectilefromsprite block=\"projectile %img=screen_image_picker from %sprite=variables_get(mySprite) with vx %vx vy %vy\"\n"]]},{"start1":3016,"length1":111,"diffs":[[1,"    export function createProjectileFromSprite(img: Image, sprite: Sprite, vx: number, vy: number): Sprite {\n"]]},{"start1":3452,"length1":169,"diffs":[[1,"    //% blockId=spritescreateprojectile block=\"projectile %img=screen_image_picker vx %vx vy %vy of kind %kind=spritetype||from sprite %sprite=variables_get(mySprite)\"\n"]]},{"start1":3835,"length1":195,"diffs":[[1,"    export function createProjectile(img: Image, vx: number, vy: number, kind?: number, sprite?: Sprite) {\n        const s = sprites.create(img, kind);\n        const sc = game.currentScene();\n"]]},{"start1":4726,"length1":94,"diffs":[[1,"        s.flags |= sprites.Flag.AutoDestroy;\n        s.flags |= sprites.Flag.DestroyOnWall;\n"]]}]},{"type":"edited","filename":"tilemap.ts","patch":[{"start1":987,"length1":107,"diffs":[[1,"        //% blockId=gameplaceontile block=\"on top of %tile(myTile) place %sprite=variables_get(mySprite)\"\n"]]},{"start1":1193,"length1":41,"diffs":[[1,"        place(mySprite: Sprite): void {\n"]]},{"start1":1352,"length1":50,"diffs":[[1,"    export class TileMap implements SpriteLike {\n"]]}]},{"type":"edited","filename":"spritemap.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"// Add your code here\n"]]},{"start1":214,"length1":62,"diffs":[[1,"        private buckets: Sprite[][];\n"]]},{"start1":318,"length1":0,"diffs":[[1,"        /**\n         * Returns a potential list of neighbors\n         */\n"]]},{"start1":564,"length1":264,"diffs":[[1,"            this.mergeAtKey(sprite.left, sprite.top, layer, n)\n            this.mergeAtKey(sprite.left, sprite.bottom, layer, n)\n            this.mergeAtKey(sprite.right, sprite.top, layer, n)\n            this.mergeAtKey(sprite.right, sprite.bottom, layer, n)\n"]]},{"start1":894,"length1":0,"diffs":[[1,"        /**\n         * Gets the overlaping sprites if any\n         * @param sprite\n         */\n"]]},{"start1":1082,"length1":72,"diffs":[[1,"            const o = n.filter(neighbor => sprite.overlapsWith(neighbor));\n            return o;\n"]]},{"start1":1696,"length1":0,"diffs":[[1,"        /**\n         * Recompute hashes for all objects\n         */\n"]]},{"start1":1833,"length1":0,"diffs":[[1,"            // rescale buckets\n"]]},{"start1":2128,"length1":55,"diffs":[[1,"            const tMap = game.currentScene().tileMap;\n"]]},{"start1":2478,"length1":137,"diffs":[[1,"            this.rowCount = Math.idiv(areaHeight, this.cellHeight)\n            this.columnCount = Math.idiv(areaWidth, this.cellWidth)\n"]]},{"start1":2614,"length1":0,"diffs":[[1,"\n"]]},{"start1":2761,"length1":178,"diffs":[[1,"            const xi = Math.clamp(0, this.columnCount, Math.idiv(x, this.cellWidth));\n            const yi = Math.clamp(0, this.rowCount, Math.idiv(y, this.cellHeight));\n"]]},{"start1":3352,"length1":55,"diffs":[[1,"            const tMap = game.currentScene().tileMap;\n\n"]]},{"start1":3719,"length1":76,"diffs":[[1,"            // is object completely out of space?\n            if (this.isOob(sprite) || (sprite.flags & sprites.Flag.Ghost))\n"]]},{"start1":4204,"length1":149,"diffs":[[1,"                    this.insertAtKey(left + Math.min(sprite.width, x * this.cellWidth), top + Math.min(sprite.height, y * this.cellHeight), sprite)\n"]]},{"start1":4596,"length1":73,"diffs":[[1,"                    if ((sprite.layer & layer)\n                        && n.indexOf(sprite) < 0)\n"]]},{"start1":4896,"length1":2,"diffs":[[1,"}"]]}]}]},{"timestamp":1756167604548,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":419,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"sprite.ts","patch":[{"start1":875,"length1":64,"diffs":[[1,"//% blockNamespace=sprites color=\"#4B7BEC\" blockGap=8\n"]]},{"start1":5253,"length1":61,"diffs":[[1,"    //% blockId=spriteimage block=\"%sprite(mySprite) image\"\n"]]},{"start1":5468,"length1":96,"diffs":[[1,"    //% blockId=spritesetimage block=\"set %sprite(mySprite) image to %img=screen_image_picker\"\n"]]},{"start1":8964,"length1":64,"diffs":[[1,"    //% blockId=\"spritegetkind\" block=\"%sprite(mySprite) kind\"\n"]]},{"start1":9184,"length1":77,"diffs":[[1,"    //% blockId=\"spritesetkind\" block=\"set %sprite(mySprite) kind to %kind\"\n"]]},{"start1":10044,"length1":82,"diffs":[[1,"    //% blockId=spritesetpos block=\"set %sprite(mySprite) position to x %x y %y\"\n"]]},{"start1":10461,"length1":86,"diffs":[[1,"    //% blockId=spritesetvel block=\"set %sprite(mySprite) velocity to vx %vx vy %vy\"\n"]]},{"start1":10965,"length1":79,"diffs":[[1,"    //% blockId=spritesay block=\"%sprite(mySprite) say %text||for %millis ms\"\n"]]},{"start1":16638,"length1":115,"diffs":[[1,"    //% blockId=startEffectOnSprite block=\"%sprite(mySprite) start %effect effect || for %duration=timePicker|ms\"\n"]]},{"start1":19792,"length1":86,"diffs":[[1,"    //% blockId=spritesetsetflag block=\"set %sprite(mySprite) %flag %on=toggleOnOff\"\n"]]},{"start1":20207,"length1":110,"diffs":[[1,"    //% blockId=spriteoverlapswith block=\"%sprite(mySprite) overlaps with %other=variables_get(otherSprite)\"\n"]]},{"start1":21767,"length1":88,"diffs":[[1,"    //% blockId=spritehasobstacle block=\"is %sprite(mySprite) hitting wall %direction\"\n"]]},{"start1":22178,"length1":81,"diffs":[[1,"    //% blockId=spriteobstacle block=\"%sprite(mySprite) wall hit on %direction\"\n"]]},{"start1":22350,"length1":58,"diffs":[[1,"    tileHitFrom(direction: CollisionDirection): number {\n"]]},{"start1":22589,"length1":81,"diffs":[[1,"    registerObstacle(direction: CollisionDirection, other: sprites2.Obstacle) {\n"]]},{"start1":23500,"length1":88,"diffs":[[1,"    //% blockId=spritedestroy block=\"destroy %sprite(mySprite) || with %effect effect\"\n"]]}]},{"type":"edited","filename":"physics.ts","patch":[{"start1":3846,"length1":74,"diffs":[[1,"                const bounce = sprite.flags & sprites.Flag.BounceOnWall;\n"]]},{"start1":4799,"length1":139,"diffs":[[1,"                            sprite.registerObstacle(right ? CollisionDirection.Right : CollisionDirection.Left, tm.getObstacle(x0, y0));\n"]]},{"start1":5868,"length1":138,"diffs":[[1,"                            sprite.registerObstacle(down ? CollisionDirection.Bottom : CollisionDirection.Top, tm.getObstacle(x0, y0));\n"]]},{"start1":6105,"length1":79,"diffs":[[1,"                if (hitWall && (sprite.flags & sprites.Flag.DestroyOnWall)) {\n"]]}]},{"type":"edited","filename":"game.ts","patch":[{"start1":104,"length1":50,"diffs":[[1,"//% groups='[\"Gameplay\", \"Prompt\"]'\n"]]},{"start1":3998,"length1":86,"diffs":[[1,"    //% blockId=gameOver block=\"game over || %win=toggleWinLose with %effect effect\"\n"]]},{"start1":6180,"length1":51,"diffs":[[1,"    //% blockId=gameupdate block=\"on game update\"\n"]]},{"start1":6633,"length1":81,"diffs":[[1,"    //% blockId=gameinterval block=\"on game update every %period=timePicker ms\"\n"]]},{"start1":7536,"length1":67,"diffs":[[1,"    //% blockId=arcade_game_runtime block=\"time since start (ms)\"\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1756165259440,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"fix\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1756167110104,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n","README.md":" ","assets.json":"","sprite.ts":"enum SpriteFlag2 {\n    //% block=\"ghost\"\n    Ghost = sprites2.Flag.Ghost,\n    //% block=\"auto destroy\"\n    AutoDestroy = sprites2.Flag.AutoDestroy,\n    //% block=\"stay in screen\"\n    StayInScreen = sprites2.Flag.StayInScreen,\n    //% block=\"destroy on wall\"\n    DestroyOnWall = sprites2.Flag.DestroyOnWall,\n    //% block=\"bounce on wall\"\n    BounceOnWall = sprites2.Flag.BounceOnWall,\n    //% block=\"show physics\"\n    ShowPhysics = sprites2.Flag.ShowPhysics\n}\n\nenum CollisionDirection2 {\n    //% block=\"left\"\n    Left = 0,\n    //% block=\"top\"\n    Top = 1,\n    //% block=\"right\"\n    Right = 2,\n    //% block=\"bottom\"\n    Bottom = 3\n}\n\ninterface SpriteLike2 {\n    z: number;\n    id: number;\n    __update(camera: scene.Camera, dt: number): void;\n    __draw(camera: scene.Camera): void;\n    __serialize(offset: number): Buffer;\n}\n\nenum FlipOption2 {\n    //% block=none\n    None,\n    //% block=\"flip x\"\n    FlipX,\n    //% block=\"flip y\"\n    FlipY,\n    //% block=\"flip x+y\"\n    FlipXY\n}\n\n/**\n * A sprite on the screen\n **/\n//% blockNamespace=sprites color=\"#4B7BEC\" blockGap=8\nclass Sprite2 implements SpriteLike2 {\n    _x: Fx8\n    _y: Fx8\n    private _z: number\n    _vx: Fx8\n    _vy: Fx8\n    _ax: Fx8\n    _ay: Fx8\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\"\n    get x(): number {\n        return Fx.toInt(this._x) + (this._image.width >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"x\"\n    set x(v: number) {\n        this._lastX = this._x;\n        this._x = Fx8(v - (this._image.width >> 1))\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\"\n    get y(): number {\n        return Fx.toInt(this._y) + (this._image.height >> 1)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"y\"\n    set y(v: number) {\n        this._lastY = this._y;\n        this._y = Fx8(v - (this._image.height >> 1))\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\"\n    get vx(): number {\n        return Fx.toFloat(this._vx)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vx (velocity x)\"\n    set vx(v: number) {\n        this._vx = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\"\n    get vy(): number {\n        return Fx.toFloat(this._vy)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"vy (velocity y)\"\n    set vy(v: number) {\n        this._vy = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\"\n    get ax(): number {\n        return Fx.toFloat(this._ax)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ax (acceleration x)\"\n    set ax(v: number) {\n        this._ax = Fx8(v)\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\"\n    get ay(): number {\n        return Fx.toFloat(this._ay)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"ay (acceleration y)\"\n    set ay(v: number) {\n        this._ay = Fx8(v)\n    }\n\n    /** \n     * Custom data\n     */\n    //%\n    data: any;\n    _kind: number;\n\n    /**\n     * A bitset of layer. Each bit is a layer, default is 1.\n     */\n    //% group=\"Physics\"\n    layer: number;\n\n    _lastX: Fx8;\n    _lastY: Fx8;\n\n    _action: number; //Used with animation library\n\n    /**\n     * Time to live in milliseconds. The lifespan decreases by 1 on each millisecond\n     * and the sprite gets destroyed when it reaches 0.\n     */\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"lifespan\"\n    lifespan: number;\n    private _image: Image;\n    private _obstacles: sprites2.Obstacle[];\n\n    private updateSay: (dt: number, camera: scene.Camera) => void;\n    private sayBubbleSprite: Sprite2;\n\n    _hitbox: game2.Hitbox;\n    _overlappers: number[];\n\n    flags: number\n    id: number\n\n    overlapHandler: (other: Sprite2) => void;\n    collisionHandlers: (() => void)[][];\n    private destroyHandler: () => void;\n\n    constructor(img: Image) {\n        this._x = Fx8(screen.width - img.width >> 1);\n        this._y = Fx8(screen.height - img.height >> 1);\n        this._z = 0\n        this._lastX = this._x;\n        this._lastY = this._y;\n        this.vx = 0\n        this.vy = 0\n        this.ax = 0\n        this.ay = 0\n        this.flags = 0\n        this.setImage(img);\n        this.setKind(-1); // not a member of any type by default\n        this.layer = 1; // by default, in layer 1\n        this.lifespan = undefined;\n        this._overlappers = [];\n    }\n\n    __serialize(offset: number): Buffer {\n        const buf = control.createBuffer(offset + 12);\n        let k = offset;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._x)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._y)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vx)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._vy)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ax)); k += 2;\n        buf.setNumber(NumberFormat.Int16LE, k, Fx.toInt(this._ay)); k += 2;\n        return buf;\n    }\n\n    /**\n     * Gets the current image\n     */\n    //% group=\"Lifecycle\"\n    //% blockId=spriteimage block=\"%sprite(mySprite) image\"\n    //% weight=8\n    get image(): Image {\n        return this._image;\n    }\n\n    /**\n     * Sets the image on the sprite\n     */\n    //% group=\"Lifecycle\"\n    //% blockId=spritesetimage block=\"set %sprite(mySprite) image to %img=screen_image_picker\"\n    //% weight=7 help=sprites/sprite/set-image\n    setImage(img: Image) {\n        if (!img) return; // don't break the sprite\n\n        let oMinX = 0;\n        let oMinY = 0;\n        let oMaxX = 0;\n        let oMaxY = 0;\n\n        // Identify old upper left corner\n        if (this._hitbox) {\n            oMinX = this._hitbox.ox;\n            oMinY = this._hitbox.oy;\n            oMaxX = this._hitbox.ox + this._hitbox.width;\n            oMaxY = this._hitbox.oy + this._hitbox.height;\n        }\n\n        this._image = img;\n        this._hitbox = game2.calculateHitBox(this);\n\n        // Identify new upper left corner\n        let nMinX = this._hitbox.ox;\n        let nMinY = this._hitbox.oy;\n        let nMaxX = this._hitbox.ox + this._hitbox.width;\n        let nMaxY = this._hitbox.oy + this._hitbox.height;\n\n        const minXDiff = oMinX - nMinX;\n        const minYDiff = oMinY - nMinY;\n        const maxXDiff = oMaxX - nMaxX;\n        const maxYDiff = oMaxY - nMaxY;\n\n        // If just a small change to the hitbox, don't change the hitbox\n        // Used for things like walking animations\n        if (oMaxX != oMinX && Math.abs(minXDiff) + Math.abs(maxXDiff) <= 2) {\n            this._hitbox.ox = oMinX;\n            this._hitbox.width = oMaxX - oMinX;\n        }\n        if (oMaxY != oMinY && Math.abs(minYDiff) + Math.abs(maxYDiff) <= 2) {\n            this._hitbox.oy = oMinY;\n            this._hitbox.height = oMaxY - oMinY;\n        }\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    get z(): number {\n        return this._z;\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"z (depth)\"\n    set z(value: number) {\n        if (value != this._z) {\n            this._z = value;\n            game.currentScene().flags |= scene.Flag.NeedsSorting;\n        }\n    }\n\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"width\"\n    get width() {\n        return this._image.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"height\"\n    get height() {\n        return this._image.height\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    get left() {\n        return Fx.toInt(this._x)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"left\"\n    set left(value: number) {\n        this._x = Fx8(value)\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    get right() {\n        return this.left + this.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"right\"\n    set right(value: number) {\n        this.left = value - this.width\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    get top() {\n        return Fx.toInt(this._y);\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine\n    set top(value: number) {\n        this._y = Fx8(value);\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    get bottom() {\n        return this.top + this.height;\n    }\n    //% group=\"Physics\" blockSetVariable=\"mySprite\"\n    //% blockCombine block=\"bottom\"\n    set bottom(value: number) {\n        this.top = value - this.height;\n    }\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritegetkind\" block=\"%sprite(mySprite) kind\"\n    //% weight=79 help=sprites/sprite/kind\n    kind() {\n        return this._kind;\n    }\n\n    /**\n     * The type of sprite\n     */\n    //% group=\"Overlaps\"\n    //% blockId=\"spritesetkind\" block=\"set %sprite(mySprite) kind to %kind\"\n    //% kind.shadow=spritetype\n    //% weight=80 help=sprites/sprite/set-kind\n    setKind(value: number) {\n        if (value == undefined || this._kind === value) return;\n\n        const spritesByKind = game2.currentScene().spritesByKind;\n        if (this._kind >= 0 && spritesByKind[this._kind])\n            spritesByKind[this._kind].remove(this);\n\n        if (value >= 0) {\n            if (!spritesByKind[value]) spritesByKind[value] = new SpriteSet2();\n            spritesByKind[value].add(this);\n        }\n\n        this._kind = value;\n    }\n\n    /**\n     * Set the sprite position in pixels starting from the top-left corner of the screen.\n     * @param x horizontal position in pixels\n     * @param y vertical position in pixels\n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetpos block=\"set %sprite(mySprite) position to x %x y %y\"\n    //% help=sprites/sprite/set-position\n    //% x.shadow=\"positionPicker\" y.shadow=\"positionPicker\"\n    setPosition(x: number, y: number): void {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Sets the sprite velocity in pixel / sec\n     * @param vx \n     * @param vy \n     */\n    //% group=\"Physics\"\n    //% weight=100\n    //% blockId=spritesetvel block=\"set %sprite(mySprite) velocity to vx %vx vy %vy\"\n    //% help=sprites/sprite/set-velociy\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    setVelocity(vx: number, vy: number): void {\n        this.vx = vx;\n        this.vy = vy;\n    }\n\n    /**\n     * Display a speech bubble with the text, for the given time\n     * @param text the text to say, eg: \":)\"\n     * @param time time to keep text on\n     */\n    //% group=\"Effects\"\n    //% weight=60\n    //% blockId=spritesay block=\"%sprite(mySprite) say %text||for %millis ms\"\n    //% millis.shadow=timePicker\n    //% inlineInputMode=inline\n    //% help=sprites/sprite/say\n    say(text: string, timeOnScreen?: number, textColor = 15, textBoxColor = 1) {\n        if (!text) {\n            this.updateSay = undefined;\n            if (this.sayBubbleSprite) {\n                this.sayBubbleSprite.destroy();\n                this.sayBubbleSprite = undefined;\n            }\n            return;\n        }\n\n        let pixelsOffset = 0;\n        let holdTextSeconds = 1.5;\n        let bubblePadding = 4;\n        let maxTextWidth = 100;\n        let font = image.font8;\n        let startX = 2;\n        let startY = 2;\n        let bubbleWidth = text.length * font.charWidth + bubblePadding;\n        let maxOffset = text.length * font.charWidth - maxTextWidth;\n        let bubbleOffset: number = this._hitbox.oy;\n        // sets the defaut scroll speed in pixels per second\n        let speed = 45;\n        const currentScene = game.currentScene();\n\n        // Calculates the speed of the scroll if scrolling is needed and a time is specified\n        if (timeOnScreen && maxOffset > 0) {\n            speed = (maxOffset + (2 * maxTextWidth)) / (timeOnScreen / 1000);\n            speed = Math.max(speed, 45);\n            holdTextSeconds = maxTextWidth / speed;\n            holdTextSeconds = Math.min(holdTextSeconds, 1.5);\n        }\n\n        if (timeOnScreen) {\n            timeOnScreen = timeOnScreen + currentScene.millis();\n        }\n\n        if (bubbleWidth > maxTextWidth + bubblePadding) {\n            bubbleWidth = maxTextWidth + bubblePadding;\n        } else {\n            maxOffset = -1;\n        }\n\n        // Destroy previous sayBubbleSprite to prevent leaking\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n            this.sayBubbleSprite = undefined;\n        }\n\n        this.sayBubbleSprite = sprites2.create(image.create(bubbleWidth, font.charHeight + bubblePadding), -1);\n\n        this.sayBubbleSprite.setFlag(SpriteFlag2.Ghost, true);\n        this.updateSay = (dt, camera) => {\n            // Update box stuff as long as timeOnScreen doesn't exist or it can still be on the screen\n            if (!timeOnScreen || timeOnScreen > currentScene.millis()) {\n                this.sayBubbleSprite.image.fill(textBoxColor);\n                // The minus 2 is how much transparent padding there is under the sayBubbleSprite\n                this.sayBubbleSprite.y = this.top + bubbleOffset - ((font.charHeight + bubblePadding) >> 1) - 2;\n                this.sayBubbleSprite.x = this.x;\n\n                if (!this.isOutOfScreen(camera)) {\n                    const ox = camera.offsetX;\n                    const oy = camera.offsetY;\n\n                    if (this.sayBubbleSprite.left - ox < 0) {\n                        this.sayBubbleSprite.left = 0;\n                    }\n\n                    if (this.sayBubbleSprite.right - ox > screen.width) {\n                        this.sayBubbleSprite.right = screen.width;\n                    }\n\n                    // If sprite bubble above the sprite gets cut off on top, place the bubble below the sprite\n                    if (this.sayBubbleSprite.top - oy < 0) {\n                        this.sayBubbleSprite.y = (this.sayBubbleSprite.y - 2 * this.y) * -1;\n                    }\n                }\n\n                // Pauses at beginning of text for holdTextSeconds length\n                if (holdTextSeconds > 0) {\n                    holdTextSeconds -= game.eventContext().deltaTime;\n                    // If scrolling has reached the end, start back at the beginning\n                    if (holdTextSeconds <= 0 && pixelsOffset > 0) {\n                        pixelsOffset = 0;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                } else {\n                    pixelsOffset += dt * speed;\n\n                    // Pause at end of text for holdTextSeconds length\n                    if (pixelsOffset >= maxOffset) {\n                        pixelsOffset = maxOffset;\n                        holdTextSeconds = maxTextWidth / speed;\n                    }\n                }\n                // If maxOffset is negative it won't scroll\n                if (maxOffset < 0) {\n                    this.sayBubbleSprite.image.print(text, startX, startY, textColor, font);\n                } else {\n                    this.sayBubbleSprite.image.print(text, startX - pixelsOffset, startY, textColor, font);\n                }\n\n                // Left side padding\n                this.sayBubbleSprite.image.fillRect(0, 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                // Right side padding\n                this.sayBubbleSprite.image.fillRect(bubbleWidth - (bubblePadding >> 1), 0, bubblePadding >> 1, font.charHeight + bubblePadding, textBoxColor);\n                // Corners removed\n                this.sayBubbleSprite.image.setPixel(0, 0, 0);\n                this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, 0, 0);\n                this.sayBubbleSprite.image.setPixel(0, font.charHeight + bubblePadding - 1, 0);\n                this.sayBubbleSprite.image.setPixel(bubbleWidth - 1, font.charHeight + bubblePadding - 1, 0);\n            } else {\n                // If can't update because of timeOnScreen then destroy the sayBubbleSprite and reset updateSay\n                this.sayBubbleSprite.destroy();\n                this.updateSay = undefined;\n            }\n        }\n    }\n\n    /**\n     * Start an effect on this sprite\n     * @param effect the type of effect to create\n     */\n    //% group=\"Effects\"\n    //% weight=90\n    //% blockId=startEffectOnSprite block=\"%sprite(mySprite) start %effect effect || for %duration=timePicker|ms\"\n    startEffect(effect: effects.ParticleEffect, duration?: number) {\n        effect.start(this, duration);\n    }\n\n    /**\n     * Indicates if the sprite is outside the screen\n     */\n    //%\n    isOutOfScreen(camera: scene.Camera): boolean {\n        const ox = camera.offsetX;\n        const oy = camera.offsetY;\n        return this.right - ox < 0 || this.bottom - oy < 0 || this.left - ox > screen.width || this.top - oy > screen.height;\n    }\n\n    __draw(camera: scene.Camera) {\n        if (this.isOutOfScreen(camera)) return;\n\n        const l = this.left - camera.drawOffsetX;\n        const t = this.top - camera.drawOffsetY;\n        screen.drawTransparentImage(this._image, l, t)\n\n        if (this.flags & SpriteFlag2.ShowPhysics) {\n            const font = image.font5;\n            const margin = 2;\n            let tx = this.left;\n            let ty = this.bottom + margin;\n            screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n            tx -= font.charWidth;\n            if (this.vx || this.vy) {\n                ty += font.charHeight + margin;\n                screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n            }\n            if (this.ax || this.ay) {\n                ty += font.charHeight + margin;\n                screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n            }\n        }\n\n        // debug info\n        if (game.debug) {\n            screen.drawRect(Fx.toInt(this._hitbox.left), Fx.toInt(this._hitbox.top), this._hitbox.width, this._hitbox.height, 1);\n        }\n    }\n\n    __update(camera: scene.Camera, dt: number) {\n        if (this.lifespan !== undefined) {\n            this.lifespan -= dt * 1000;\n            if (this.lifespan <= 0) {\n                this.lifespan = undefined;\n                this.destroy();\n            }\n        }\n        if ((this.flags & sprites2.Flag.AutoDestroy)\n            && this.isOutOfScreen(camera)) {\n            this.destroy()\n        }\n\n        const bounce = this.flags & sprites2.Flag.BounceOnWall;\n        const tm = game.currentScene().tileMap;\n        if (this.flags & sprites2.Flag.StayInScreen || (bounce && !tm)) {\n            if (this.left < camera.offsetX) {\n                this.left = camera.offsetX;\n                if (bounce) this.vx = -this.vx;\n            }\n            else if (this.right > camera.offsetX + screen.width) {\n                this.right = camera.offsetX + screen.width;\n                if (bounce) this.vx = -this.vx;\n            }\n\n            if (this.top < camera.offsetY) {\n                this.top = camera.offsetY;\n                if (bounce) this.vy = -this.vy;\n            }\n            else if (this.bottom > camera.offsetY + screen.height) {\n                this.bottom = camera.offsetY + screen.height;\n                if (bounce) this.vy = -this.vy;\n            }\n        }\n\n        // Say text\n        if (this.updateSay) {\n            this.updateSay(dt, camera);\n        }\n    }\n\n    /**\n     * Set a sprite flag\n     */\n    //% group=\"Effects\"\n    //% weight=30\n    //% blockId=spritesetsetflag block=\"set %sprite(mySprite) %flag %on=toggleOnOff\"\n    //% flag.defl=SpriteFlag2.StayInScreen\n    //% help=sprites/sprite/set-flag\n    setFlag(flag: SpriteFlag2, on: boolean) {\n        if (on) this.flags |= flag\n        else this.flags = ~(~this.flags | flag);\n    }\n\n    /**\n     * Check if this sprite overlaps another sprite\n     * @param other\n     */\n    //% group=\"Overlaps\"\n    //% blockId=spriteoverlapswith block=\"%sprite(mySprite) overlaps with %other=variables_get(otherSprite)\"\n    //% help=sprites/sprite/overlaps-with\n    //% weight=90\n    overlapsWith(other: Sprite2) {\n        control.enablePerfCounter(\"overlapsCPP\")\n        if (other == this) return false;\n        if (this.flags & sprites2.Flag.Ghost)\n            return false\n        if (other.flags & sprites2.Flag.Ghost)\n            return false\n        return other._image.overlapsWith(this._image, this.left - other.left, this.top - other.top)\n    }\n\n    /**\n     * Registers code when the sprite overlaps with another sprite\n     * @param spriteType sprite type to match\n     * @param handler\n     */\n    //% group=\"Overlaps\"\n    //% afterOnStart=true\n    //% help=sprites/sprite/on-overlap\n    onOverlap(handler: (other: Sprite2) => void) {\n        this.overlapHandler = handler;\n    }\n\n    /**\n     * Registers code when the sprite collides with an obstacle\n     * @param direction\n     * @param handler\n     */\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    onCollision(direction: CollisionDirection, tileIndex: number, handler: () => void) {\n        if (!this.collisionHandlers)\n            this.collisionHandlers = [];\n\n        direction = Math.max(0, Math.min(3, direction | 0));\n\n        if (!this.collisionHandlers[direction])\n            this.collisionHandlers[direction] = [];\n\n        this.collisionHandlers[direction][tileIndex] = handler;\n    }\n\n    /**\n     * Check if there is an obstacle in the given direction\n     * @param direction\n     */\n    //% blockId=spritehasobstacle block=\"is %sprite(mySprite) hitting wall %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/is-hitting-tile\n    isHittingTile(direction: CollisionDirection): boolean {\n        return this._obstacles && !!this._obstacles[direction];\n    }\n\n    /**\n     * Get the obstacle sprite in a given direction if any\n     * @param direction\n     */\n    //% blockId=spriteobstacle block=\"%sprite(mySprite) wall hit on %direction\"\n    //% blockNamespace=\"scene\" group=\"Collisions\"\n    //% help=sprites/sprite/tile-hit-from\n    tileHitFrom(direction: CollisionDirection): number {\n        return (this._obstacles && this._obstacles[direction]) ? this._obstacles[direction].tileIndex : -1;\n    }\n\n    clearObstacles() {\n        this._obstacles = undefined;\n    }\n\n    registerObstacle(direction: CollisionDirection, other: sprites2.Obstacle) {\n        if (other == undefined) return;\n        if (!this._obstacles)\n            this._obstacles = [];\n        this._obstacles[direction] = other;\n\n        const handler = (this.collisionHandlers && this.collisionHandlers[direction]) ? this.collisionHandlers[direction][other.tileIndex] : undefined;\n        if (handler) handler();\n        const scene = game2.currentScene();\n        scene.collisionHandlers\n            .filter(h => h.kind == this.kind() && h.tile == other.tileIndex)\n            .forEach(h => h.handler(this));\n    }\n\n    /**\n     * Run code when the sprite is destroyed\n     * @param handler\n     */\n    //% group=\"Lifecycle\"\n    //% weight=9\n    onDestroyed(handler: () => void) {\n        this.destroyHandler = handler\n    }\n\n    /**\n     * Destroy the sprite\n     */\n    //% group=\"Effects\"\n    //% weight=80\n    //% blockId=spritedestroy block=\"destroy %sprite(mySprite) || with %effect effect\"\n    //% help=sprites/sprite/destroy\n    destroy(effect?: effects.ParticleEffect) {\n        if (this.flags & sprites2.Flag.Destroyed)\n            return;\n\n        if (effect) {\n            // effect.destroy(this);\n            return;\n        }\n\n        this.flags |= sprites2.Flag.Destroyed\n        const scene = game2.currentScene();\n        // When current sprite is destroyed, destroys sayBubbleSprite if defined\n        if (this.sayBubbleSprite) {\n            this.sayBubbleSprite.destroy();\n        }\n        scene.allSprites.removeElement(this);\n        if (this.kind() >= 0 && scene.spritesByKind[this.kind()])\n            scene.spritesByKind[this.kind()].remove(this);\n        scene.physicsEngine.removeSprite(this);\n        if (this.destroyHandler)\n            this.destroyHandler();\n        scene.destroyedHandlers\n            .filter(h => h.kind == this.kind())\n            .forEach(h => h.handler(this));\n    }\n\n    toString() {\n        return `${this.id}(${this.x},${this.y})->(${this.vx},${this.vy})`;\n    }\n}\n\nnamespace sprites2 {\n    enum ObstacleFlags {\n        Moved = 1 << 4,\n        Dead = 1 << 5\n    }\n\n    export interface Obstacle {\n        x: number;\n        y: number;\n        left: number;\n        right: number;\n        top: number;\n        bottom: number;\n        width: number;\n        height: number;\n        layer: number;\n        image: Image;\n        tileIndex: number;\n    }\n\n    export class StaticObstacle implements Obstacle {\n        layer: number;\n        image: Image;\n        tileIndex: number;\n\n        top: number;\n        left: number;\n\n        constructor(image: Image, top: number, left: number, layer: number, tileIndex?: number) {\n            this.image = image;\n            this.layer = layer;\n            this.top = top;\n            this.left = left;\n            this.tileIndex = tileIndex;\n        }\n\n        get x(): number {\n            return this.left + this.width >> 1;\n        }\n\n        get y(): number {\n            return this.top + this.height >> 1;\n        }\n\n        get height(): number {\n            return this.image.height;\n        }\n\n        get width(): number {\n            return this.image.width;\n        }\n\n        get bottom(): number {\n            return this.top + this.height;\n        }\n\n        get right(): number {\n            return this.left + this.width;\n        }\n    }\n}","sprites.ts":"// Add your code here\n/*\nFrame handlers:\n 10 - physics and collisions\n 20 - frame()\n 60 - screen/sprite background\n 90 - drawing sprites\n 95 - drawing score\n100 - loops.menu()\n200 - screen refresh\n*/\n\n/**\n * Sprites on screen\n */\n//% weight=99 color=\"#4B7BEC\" icon=\"\\uf1d8\"\n//% groups='[\"Create\", \"Physics\", \"Effects\", \"Projectiles\", \"Overlaps\", \"Lifecycle\"]'\nnamespace sprites2 {\n\n    /**\n     * Create a new sprite from an image\n     * @param img the image\n     */\n    //% group=\"Create\"\n    //% blockId=spritescreate block=\"sprite %img=screen_image_picker of kind %kind=spritetype\"\n    //% expandableArgumentMode=toggle\n    //% blockSetVariable=mySprite\n    //% weight=100 help=sprites/create\n    export function create(img: Image, kind?: number): Sprite2 {\n        const scene = game.currentScene();\n        const sprite = new Sprite2(img)\n        sprite.setKind(kind);\n        scene.addSprite(sprite);\n        scene.physicsEngine.addSprite(sprite);\n\n        // run on created handlers\n        scene.createdHandlers\n            .filter(h => h.kind == kind)\n            .forEach(h => h.handler(sprite));\n\n        return sprite\n    }\n\n    /**\n     * Return an array of all sprites of the given kind.\n     * @param kind the target kind\n     */\n    //% blockId=allOfKind block=\"array of sprites of kind %kind=spritetype\"\n    //% blockNamespace=\"arrays\" blockSetVariable=\"sprite list\"\n    //% weight=87\n    export function allOfKind(kind: number): Sprite[] {\n        const spritesByKind = game.currentScene().spritesByKind;\n        if (!(kind >= 0) || !spritesByKind[kind]) return [];\n        else return spritesByKind[kind].sprites();\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromside block=\"projectile %img=screen_image_picker from side with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-side\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSide(img: Image, vx: number, vy: number) {\n        return createProjectile(img, vx, vy, 1);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectilefromsprite block=\"projectile %img=screen_image_picker from %sprite=variables_get(mySprite) with vx %vx vy %vy\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    //% weight=99 help=sprites/create-projectile-from-sprite\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% vy.defl=100\n    export function createProjectileFromSprite(img: Image, sprite: Sprite, vx: number, vy: number): Sprite {\n        return createProjectile(img, vx, vy, 1, sprite);\n    }\n\n    /**\n     * Create a new sprite with given speed, and place it at the edge of the screen so it moves towards the middle.\n     * The sprite auto-destroys when it leaves the screen. You can modify position after it's created.\n     */\n    //% group=\"Projectiles\"\n    //% blockId=spritescreateprojectile block=\"projectile %img=screen_image_picker vx %vx vy %vy of kind %kind=spritetype||from sprite %sprite=variables_get(mySprite)\"\n    //% weight=99 help=sprites/create-projectile\n    //% blockSetVariable=projectile\n    //% inlineInputMode=inline\n    //% expandableArgumentMode=toggle\n    //% vy.defl=100\n    //% deprecated=true blockHidden=true\n    export function createProjectile(img: Image, vx: number, vy: number, kind?: number, sprite?: Sprite) {\n        const s = sprites.create(img, kind);\n        const sc = game.currentScene();\n        s.vx = vx\n        s.vy = vy\n\n        // put it at the edge of the screen so that it moves towards the middle\n        // If the scene has a tile map, place the sprite fully on the screen\n\n        const xOff = sc.tileMap ? -(s.width >> 1) : (s.width >> 1) - 1;\n        const yOff = sc.tileMap ? -(s.height >> 1) : (s.height >> 1) - 1;\n\n        while (vx == 0 && vy == 0) {\n            vx = Math.randomRange(-100, 100);\n            vy = Math.randomRange(-100, 100);\n        }\n\n        if (vx < 0)\n            s.x = screen.width + xOff\n        else if (vx > 0)\n            s.x = -xOff\n\n        if (vy < 0)\n            s.y = screen.height + yOff\n        else if (vy > 0)\n            s.y = -yOff\n\n        s.flags |= sprites.Flag.AutoDestroy;\n        s.flags |= sprites.Flag.DestroyOnWall;\n\n        if (sprite) {\n            s.x = sprite.x;\n            s.y = sprite.y;\n        }\n\n        return s\n    }\n\n    export enum Flag {\n        Ghost = 1 << 0, // doesn't collide with other sprites\n        Destroyed = 1 << 1,\n        AutoDestroy = 1 << 2, // remove the sprite when no longer visible\n        StayInScreen = 1 << 3, // sprite cannot move outside the camera region\n        DestroyOnWall = 1 << 4, // destroy sprite on contact with wall\n        BounceOnWall = 1 << 5, // Bounce on walls\n        ShowPhysics = 1 << 6, // display position, velocity, acc\n    }\n}\n","physics.ts":"class PhysicsEngine2 {\n    constructor() {\n    }\n\n    /**\n     * Adds sprite to the physics\n     * @param sprite\n     */\n    addSprite(sprite: Sprite2) { }\n\n    removeSprite(sprite: Sprite2) { }\n\n    moveSprite(s: Sprite2, tm: tiles2.TileMap, dx: Fx8, dy: Fx8) { }\n\n    draw() { }\n\n    /** Apply physics */\n    move(dt: number) { }\n\n    /**\n     * Apply collisions\n     */\n    collisions() { }\n\n    overlaps(sprite: Sprite2): Sprite2[] { return []; }\n}\n\nconst MAX_DISTANCE = Fx8(15); // pixels\nconst MAX_TIME_STEP2 = Fx8(0.1); // seconds\nconst MAX_VELOCITY = Fx.div(MAX_DISTANCE, MAX_TIME_STEP2);\nconst NEG_MAX_VELOCITY = Fx.neg(MAX_VELOCITY)\nconst GAP = Fx8(0.1);\n\n/**\n * A physics engine that does simple AABB bounding box check\n */\nclass ArcadePhysicsEngine2 extends PhysicsEngine2 {\n    protected sprites: Sprite2[];\n    protected map: sprites2.SpriteMap;\n\n    constructor() {\n        super();\n        this.sprites = [];\n    }\n\n    addSprite(sprite: Sprite2) {\n        this.sprites.push(sprite);\n    }\n\n    removeSprite(sprite: Sprite2) {\n        this.sprites.removeElement(sprite);\n    }\n\n    draw() {\n        if (this.map)\n            this.map.draw();\n    }\n\n    move(dt: number) {\n        const dtf = Fx.min(MAX_TIME_STEP2, Fx8(dt))\n        const dt2 = Fx.idiv(dtf, 2)\n\n        const tm = game2.currentScene().tileMap;\n\n        for (let s of this.sprites) {\n            const ovx = constrain(s._vx);\n            const ovy = constrain(s._vy);\n\n            s._vx = constrain(Fx.add(s._vx, Fx.mul(s._ax, dtf)))\n            s._vy = constrain(Fx.add(s._vy, Fx.mul(s._ay, dtf)))\n\n            this.moveSprite(s, tm,\n                Fx.mul(Fx.add(s._vx, ovx), dt2),\n                Fx.mul(Fx.add(s._vy, ovy), dt2))\n        }\n    }\n\n    collisions() {\n        control.enablePerfCounter(\"phys_collisions\")\n\n        // 1: refresh non-ghost collision map\n        const colliders = this.sprites.filter(sprite => !(sprite.flags & sprites2.Flag.Ghost));\n\n        if (colliders.length < 10) {\n            // not enough sprite, just brute force it\n            this.map = undefined;\n        } else {\n            if (!this.map) this.map = new sprites2.SpriteMap();\n            this.map.update(colliders);\n        }\n\n        // 2: go through sprite and handle collisions\n        const scene = game2.currentScene();\n        const tm = scene.tileMap;\n\n        for (const sprite of colliders) {\n            const overSprites = scene.physicsEngine.overlaps(sprite);\n            for (const overlapper of overSprites) {\n                const higher = sprite.id > overlapper.id ? sprite : overlapper;\n                const lower = higher === sprite ? overlapper : sprite;\n\n                if (higher._overlappers.indexOf(lower.id) === -1) {\n                    if (sprite.overlapHandler) {\n                        higher._overlappers.push(lower.id);\n                        control.runInParallel(() => {\n                            sprite.overlapHandler(overlapper);\n                            higher._overlappers.removeElement(lower.id);\n                        });\n                    }\n\n                    scene.overlapHandlers\n                        .filter(h => h.kind == sprite.kind() && h.otherKind == overlapper.kind())\n                        .forEach(h => {\n                            higher._overlappers.push(lower.id);\n                            control.runInParallel(() => {\n                                h.handler(sprite, overlapper);\n                                higher._overlappers.removeElement(lower.id);\n                            });\n                        });\n                }\n            }\n\n            sprite.clearObstacles();\n\n            if (tm && tm.enabled) {\n                const xDiff = Fx.sub(sprite._x, sprite._lastX);\n                const yDiff = Fx.sub(sprite._y, sprite._lastY);\n\n                let hitWall = false;\n                const bounce = sprite.flags & sprites.Flag.BounceOnWall;\n\n                if (xDiff !== Fx.zeroFx8) {\n                    const right = xDiff > Fx.zeroFx8;\n                    const x0 = Fx.toIntShifted(Fx.add(right ? Fx.iadd(1, sprite._hitbox.right) : sprite._hitbox.left, Fx8(0.5)), 4);\n                    for (let y = Fx.sub(sprite._hitbox.top, yDiff); y < Fx.iadd(16, Fx.sub(sprite._hitbox.bottom, yDiff)); y = Fx.iadd(16, y)) {\n                        const y0 = Fx.toIntShifted(Fx.add(Fx.min(y, Fx.sub(sprite._hitbox.bottom, yDiff)), Fx8(0.5)), 4);\n                        if (tm.isObstacle(x0, y0)) {\n                            hitWall = true;\n                            if (bounce) {\n                                sprite._vx = Fx.neg(sprite._vx);\n                            }\n                            sprite._x = Fx.iadd(-sprite._hitbox.ox, right ? Fx.sub(Fx8(x0 << 4), Fx8(sprite._hitbox.width)) : Fx8((x0 + 1) << 4));\n                            sprite.registerObstacle(right ? CollisionDirection.Right : CollisionDirection.Left, tm.getObstacle(x0, y0));\n                            break;\n                        }\n                    }\n                }\n                if (yDiff !== Fx.zeroFx8) {\n                    const down = yDiff > Fx.zeroFx8;\n                    const y0 = Fx.toIntShifted(Fx.add(down ? Fx.iadd(1, sprite._hitbox.bottom) : sprite._hitbox.top, Fx8(0.5)), 4);\n                    for (let x = sprite._hitbox.left; x < Fx.iadd(16, sprite._hitbox.right); x = Fx.iadd(16, x)) {\n                        const x0 = Fx.toIntShifted(Fx.add(Fx.min(x, sprite._hitbox.right), Fx8(0.5)), 4);\n                        if (tm.isObstacle(x0, y0)) {\n                            hitWall = true;\n                            if (bounce) {\n                                sprite._vy = Fx.neg(sprite._vy);\n                            }\n                            sprite._y = Fx.iadd(-sprite._hitbox.oy, down ? Fx.sub(Fx8(y0 << 4), Fx8(sprite._hitbox.height)) : Fx8((y0 + 1) << 4));\n                            sprite.registerObstacle(down ? CollisionDirection.Bottom : CollisionDirection.Top, tm.getObstacle(x0, y0));\n                            break;\n                        }\n                    }\n                }\n                if (hitWall && (sprite.flags & sprites.Flag.DestroyOnWall)) {\n                    sprite.destroy();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns sprites that overlap with the given sprite. If type is non-zero, also filter by type.\n     * @param sprite\n     * @param layer\n     */\n    overlaps(sprite: Sprite2): Sprite2[] {\n        if (this.map)\n            return this.map.overlaps(sprite);\n        else {\n            const layer = sprite.layer;\n            const r: Sprite2[] = [];\n            const n = this.sprites.length;\n            for (let i = 0; i < n; ++i) {\n                if ((layer & this.sprites[i].layer)\n                    && sprite.overlapsWith(this.sprites[i]))\n                    r.push(this.sprites[i]);\n            }\n            return r;\n        }\n    }\n\n    public moveSprite(s: Sprite2, tm: tiles2.TileMap, dx: Fx8, dy: Fx8) {\n        s._lastX = s._x;\n        s._lastY = s._y;\n        s._x = Fx.add(s._x, dx);\n        s._y = Fx.add(s._y, dy);\n    }\n}\n\nfunction constrain(v: Fx8) {\n    return Fx.max(Fx.min(MAX_VELOCITY, v), NEG_MAX_VELOCITY)\n}\n\n","tilemap.ts":"// Add your code here\nnamespace tiles2 {\n    class TileSet {\n        image: Image;\n        obstacle: boolean;\n        constructor(image: Image, collisions: boolean) {\n            this.image = image;\n            this.obstacle = collisions;\n        }\n    }\n\n    /**\n     * A tile in the tilemap\n     **/\n    //% blockNamespace=scene color=\"#401255\" blockGap=8\n    export class Tile {\n        private _row: number;\n        private _col: number;\n        private _map: Image;\n\n        constructor(col: number, row: number, map: Image) {\n            this._col = col;\n            this._row = row;\n            this._map = map;\n        }\n\n        get x(): number {\n            return (this._col << 4) + 8;\n        }\n\n        get y(): number {\n            return (this._row << 4) + 8;\n        }\n\n        get tileSet(): number {\n            return this._map.getPixel(this._col, this._row);\n        }\n\n        /**\n         * Center the given sprite on this tile\n         * @param sprite\n         */\n        //% blockId=gameplaceontile block=\"on top of %tile(myTile) place %sprite=variables_get(mySprite)\"\n        //% blockNamespace=\"scene\" group=\"Tiles\"\n        //% weight=25\n        //% help=scene/place\n        place(mySprite: Sprite): void {\n            if (!mySprite) return;\n\n            mySprite.x = this.x;\n            mySprite.y = this.y;\n        }\n    }\n\n    export class TileMap implements SpriteLike {\n        id: number;\n        z: number;\n\n        private _layer: number;\n\n        private _map: Image;\n        private _tileSets: TileSet[];\n\n        constructor() {\n            this._tileSets = [];\n            this._layer = 1;\n            this.z = -1;\n\n            const sc = game.currentScene();\n            sc.addSprite(this);\n            sc.flags |= scene.Flag.NeedsSorting;\n        }\n\n        offsetX(value: number) {\n            return Math.clamp(0, Math.max(this.areaWidth() - screen.width, 0), value);\n        }\n\n        offsetY(value: number) {\n            return Math.clamp(0, Math.max(this.areaHeight() - screen.height, 0), value);\n        }\n\n        areaWidth() {\n            return this._map ? (this._map.width << 4) : 0;\n        }\n\n        areaHeight() {\n            return this._map ? (this._map.height << 4) : 0;\n        }\n\n        get layer(): number {\n            return this._layer;\n        }\n\n        set layer(value: number) {\n            if (this._layer != value) {\n                this._layer = value;\n            }\n        }\n\n        get enabled(): boolean {\n            return !!this._map;\n        }\n\n        setTile(index: number, img: Image, collisions?: boolean) {\n            if (this.isInvalidIndex(index)) return;\n            this._tileSets[index] = new TileSet(img, collisions);\n        }\n\n        setMap(map: Image) {\n            this._map = map;\n        }\n\n        public getTile(col: number, row: number): Tile {\n            if (this.isOutsideMap(col, row)) return undefined;\n            return new Tile(col, row, this._map);\n        }\n\n        public setTileAt(col: number, row: number, index: number): void {\n            if (!this.isOutsideMap(col, row) && !this.isInvalidIndex(index))\n                this._map.setPixel(col, row, index);\n        }\n\n        public getTilesByType(index: number): Tile[] {\n            if (this.isInvalidIndex(index) || !this.enabled) return undefined;\n\n            let output: Tile[] = [];\n            for (let col = 0; col < this._map.width; ++col) {\n                for (let row = 0; row < this._map.height; ++row) {\n                    let currTile = this._map.getPixel(col, row);\n                    if (currTile === index) {\n                        output.push(new Tile(col, row, this._map));\n                    }\n                }\n            }\n            return output;\n        }\n\n        __serialize(offset: number): Buffer { return undefined; }\n\n        __update(camera: scene.Camera, dt: number): void { }\n\n        /**\n         * Draws all visible\n         */\n        __draw(camera: scene.Camera): void {\n            if (!this.enabled) return;\n\n            const offsetX = camera.drawOffsetX & 0xf;\n            const offsetY = camera.drawOffsetY & 0xf;\n            const x0 = Math.max(0, camera.drawOffsetX >> 4);\n            const xn = Math.min(this._map.width, ((camera.drawOffsetX + screen.width) >> 4) + 1);\n            const y0 = Math.max(0, camera.drawOffsetY >> 4);\n            const yn = Math.min(this._map.height, ((camera.drawOffsetY + screen.height) >> 4) + 1);\n\n            for (let x = x0; x <= xn; ++x) {\n                for (let y = y0; y <= yn; ++y) {\n                    const index = this._map.getPixel(x, y);\n                    const tile = this._tileSets[index] || this.generateTile(index);\n                    if (tile) {\n                        screen.drawTransparentImage(tile.image, ((x - x0) << 4) - offsetX, ((y - y0) << 4) - offsetY)\n                    }\n                }\n            }\n        }\n\n        private generateTile(index: number): TileSet {\n            if (index == 0) return undefined;\n\n            const img = image.create(16, 16);\n            img.fill(index);\n            return this._tileSets[index] = new TileSet(img, false);\n        }\n\n        private isOutsideMap(col: number, row: number): boolean {\n            return !this.enabled || col < 0 || col >= this._map.width\n                || row < 0 || row >= this._map.height;\n        }\n\n        private isInvalidIndex(index: number): boolean {\n            return index < 0 || index > 0xf;\n        }\n\n        draw(camera: scene.Camera) {\n            if (!this.enabled) return;\n\n            if (game.debug) {\n                const offsetX = -camera.drawOffsetX;\n                const offsetY = -camera.drawOffsetY;\n                const x0 = Math.max(0, -(offsetX >> 4));\n                const xn = Math.min(this._map.width, (-offsetX + screen.width) >> 4);\n                const y0 = Math.max(0, -(offsetY >> 4));\n                const yn = Math.min(this._map.height, (-offsetY + screen.height) >> 4);\n                for (let x = x0; x <= xn; ++x) {\n                    screen.drawLine(\n                        (x << 4) + offsetX,\n                        offsetY,\n                        (x << 4) + offsetX,\n                        (this._map.height << 4) + offsetY, 1)\n                }\n                for (let y = y0; y <= yn; ++y) {\n                    screen.drawLine(\n                        offsetX,\n                        (y << 4) + offsetY,\n                        (this._map.width << 4) + offsetX,\n                        (y << 4) + offsetY,\n                        1)\n                }\n            }\n        }\n\n        public update(camera: scene.Camera) {\n        }\n\n        public collisions(s: Sprite): sprites.Obstacle[] {\n            let overlappers: sprites.StaticObstacle[] = [];\n\n            if (this.enabled && (s.layer & this.layer) && !(s.flags & sprites.Flag.Ghost)) {\n                const x0 = Math.max(0, s.left >> 4);\n                const xn = Math.min(this._map.width, (s.right >> 4) + 1);\n                const y0 = Math.max(0, s.top >> 4);\n                const yn = Math.min(this._map.height, (s.bottom >> 4) + 1);\n\n                // let res = `x: ${x0}-${xn} y: ${y0}-${yn} HIT:`;\n                for (let x = x0; x <= xn; ++x) {\n                    const left = x << 4;\n                    for (let y = y0; y <= yn; ++y) {\n                        const index = this._map.getPixel(x, y);\n                        const tile = this._tileSets[index] || this.generateTile(index);\n                        if (tile && tile.obstacle) {\n                            const top = y << 4;\n                            if (tile.image.overlapsWith(s.image, s.left - left, s.top - top)) {\n                                overlappers.push(new sprites.StaticObstacle(tile.image, top, left, this.layer, index));\n                            }\n                        }\n                    }\n                }\n            }\n\n            return overlappers;\n        }\n\n        public isObstacle(col: number, row: number) {\n            if (!this.enabled) return false;\n            if (this.isOutsideMap(col, row)) return true;\n\n            let t = this._tileSets[this._map.getPixel(col, row)];\n            return t && t.obstacle;\n        }\n\n        public getObstacle(col: number, row: number) {\n            if (!this.enabled) return undefined;\n            if (this.isOutsideMap(col, row)) return undefined;\n\n            const index = this._map.getPixel(col, row);\n            const tile = this._tileSets[index] || this.generateTile(index);\n            if (tile.obstacle) {\n                return new sprites.StaticObstacle(tile.image, row << 4, col << 4, this.layer, index);\n            }\n            return undefined;\n        }\n    }\n}\n","scene.ts":"// Add your code here\n/**\n * Control the background, tiles and camera\n */\nnamespace scene2 {\n    export enum Flag {\n        NeedsSorting = 1 << 1,\n    }\n\n    export interface SpriteHandler {\n        kind: number;\n        handler: (sprite: Sprite2) => void;\n    }\n\n    export interface OverlapHandler {\n        kind: number;\n        otherKind: number;\n        handler: (sprite2: Sprite2, otherSprite: Sprite2) => void;\n    }\n\n    export interface CollisionHandler {\n        kind: number;\n        tile: number;\n        handler: (sprite: Sprite2) => void\n    }\n\n    export class Scene {\n        eventContext: control.EventContext;\n        background: scene.Background;\n        tileMap: tiles2.TileMap;\n        allSprites: SpriteLike[];\n        private spriteNextId: number;\n        spritesByKind: SpriteSet2[];\n        physicsEngine: PhysicsEngine2;\n        camera: scene.Camera;\n        flags: number;\n        destroyedHandlers: SpriteHandler[];\n        createdHandlers: SpriteHandler[];\n        overlapHandlers: OverlapHandler[];\n        collisionHandlers: CollisionHandler[];\n        private _millis: number;\n        private _data: any;\n\n        constructor(eventContext: control.EventContext) {\n            this.eventContext = eventContext;\n            this.flags = 0;\n            this.physicsEngine = new ArcadePhysicsEngine2();\n            this.camera = new scene.Camera();\n            this.background = new scene.Background(this.camera);\n            this.destroyedHandlers = [];\n            this.createdHandlers = [];\n            this.overlapHandlers = [];\n            this.collisionHandlers = [];\n            this.spritesByKind = [];\n            this._data = {};\n            this._millis = 0;\n        }\n\n        init() {\n            if (this.allSprites) return;\n\n            this.allSprites = [];\n            this.spriteNextId = 0;\n            // update controller state\n            this.eventContext.registerFrameHandler(8, () => {\n                this._millis += this.eventContext.deltaTimeMillis;\n                control.enablePerfCounter(\"controller_update\")\n                controller.__update(this.eventContext.deltaTime);\n            })\n            // update sprites in tilemap\n            this.eventContext.registerFrameHandler(9, () => {\n                control.enablePerfCounter(\"tilemap_update\")\n                if (this.tileMap) {\n                    this.tileMap.update(this.camera);\n                }\n            })\n            // apply physics 10\n            this.eventContext.registerFrameHandler(10, () => {\n                control.enablePerfCounter(\"physics\")\n                const dt = this.eventContext.deltaTime;\n                this.physicsEngine.move(dt);\n            })\n            // user update 20\n            // apply collisions 30\n            this.eventContext.registerFrameHandler(30, () => {\n                control.enablePerfCounter(\"collisions\")\n                const dt = this.eventContext.deltaTime;\n                this.physicsEngine.collisions();\n                this.camera.update();\n                for (const s of this.allSprites)\n                    s.__update(this.camera, dt);\n            })\n            // render background 60\n            this.eventContext.registerFrameHandler(60, () => {\n                control.enablePerfCounter(\"render background\")\n                this.background.draw();\n            })\n            // paint 75\n            // render sprites 90\n            this.eventContext.registerFrameHandler(90, () => {\n                control.enablePerfCounter(\"sprite_draw\")\n                if (this.flags & Flag.NeedsSorting)\n                    this.allSprites.sort(function (a, b) { return a.z - b.z || a.id - b.id; })\n                for (const s of this.allSprites)\n                    s.__draw(this.camera);\n            })\n            // render diagnostics\n            this.eventContext.registerFrameHandler(150, () => {\n                if (game.stats && control.EventContext.onStats) {\n                    control.EventContext.onStats(\n                        control.EventContext.lastStats +\n                        ` sprites:${this.allSprites.length}`\n                    )\n                }\n                if (game.debug)\n                    this.physicsEngine.draw();\n                game.consoleOverlay.draw();\n                // clear flags\n                this.flags = 0;\n            });\n            // update screen\n            this.eventContext.registerFrameHandler(200, control.__screen.update);\n            // register start menu\n            scene.systemMenu.register();\n        }\n\n        get data() {\n            return this._data;\n        }\n\n        /**\n         * Gets the elapsed time in the scene\n         */\n        millis(): number {\n            return this._millis;\n        }\n\n        addSprite(sprite: SpriteLike2) {\n            this.allSprites.push(sprite);\n            sprite.id = this.spriteNextId++;\n        }\n\n        destroy() {\n            this.eventContext = undefined;\n            this.background = undefined;\n            this.tileMap = undefined;\n            this.allSprites = undefined;\n            this.spriteNextId = undefined;\n            this.spritesByKind = undefined;\n            this.physicsEngine = undefined;\n            this.camera = undefined;\n            this.flags = undefined;\n            this.destroyedHandlers = undefined;\n            this.createdHandlers = undefined;\n            this.overlapHandlers = undefined;\n            this.collisionHandlers = undefined;\n            this._data = undefined;\n        }\n    }\n}\n","game.ts":"// Add your code here\n/**\n * Game transitions and dialog\n **/\n//% color=#008272 weight=97 icon=\"\\uf111\"\n//% groups='[\"Gameplay\", \"Prompt\"]'\nnamespace game2 {\n    /**\n     * Determines if diagnostics are shown\n     */\n    export let debug = false;\n    export let stats = false;\n    export let winEffect: effects.BackgroundEffect = undefined;\n    export let loseEffect: effects.BackgroundEffect = undefined;\n    let loseSound: music.Melody = undefined;\n    let winSound: music.Melody = undefined;\n\n    let _scene: scene2.Scene;\n    let _sceneStack: scene2.Scene[];\n\n    export function currentScene(): scene2.Scene {\n        init();\n        return _scene;\n    }\n\n    let __waitAnyButton: () => void\n    let __isOver = false;\n\n    export function setWaitAnyButton(f: () => void) {\n        __waitAnyButton = f\n    }\n\n    export function waitAnyButton() {\n        if (__waitAnyButton) __waitAnyButton()\n        else pause(3000)\n    }\n\n    export function eventContext(): control.EventContext {\n        init();\n        return _scene.eventContext;\n    }\n\n    function init() {\n        if (!_scene) _scene = new scene2.Scene(control.pushEventContext());\n        _scene.init();\n\n        if (!winEffect)\n            winEffect = effects.confetti;\n        if (!loseEffect)\n            loseEffect = effects.melt;\n\n        if (!winSound)\n            winSound = music.powerUp;\n        if (!loseSound)\n            loseSound = music.wawawawaa;\n    }\n\n    export function pushScene() {\n        init();\n        particles.clearAll();\n        particles.disableAll();\n        if (!_sceneStack) _sceneStack = [];\n        _sceneStack.push(_scene);\n        _scene = undefined;\n        init();\n    }\n\n    export function popScene() {\n        if (_sceneStack && _sceneStack.length) {\n            // pop scenes from the stack\n            _scene = _sceneStack.pop();\n            control.popEventContext();\n        } else if (_scene) {\n            // post last scene\n            control.popEventContext();\n            _scene = undefined;\n        }\n        if (_scene)\n            particles.enableAll();\n    }\n\n    function showDialogBackground(h: number, c: number) {\n        const top = (screen.height - h) >> 1;\n        screen.fillRect(0, top, screen.width, h, 0)\n        screen.drawLine(0, top, screen.width, top, 1)\n        screen.drawLine(0, top + h - 1, screen.width, top + h - 1, 1)\n\n        return top;\n    }\n\n    export function showDialog(title: string, subtitle: string, footer?: string) {\n        init();\n        const font = image.font8;\n        let h = 8;\n        if (title)\n            h += font.charHeight;\n        if (subtitle)\n            h += 2 + font.charHeight\n        h += 8;\n        const top = showDialogBackground(h, 9)\n        if (title)\n            screen.print(title, 8, top + 8, screen.isMono ? 1 : 7, font);\n        if (subtitle)\n            screen.print(subtitle, 8, top + 8 + font.charHeight + 2, screen.isMono ? 1 : 6, font);\n        if (footer) {\n            screen.print(\n                footer,\n                screen.width - footer.length * font.charWidth - 8,\n                screen.height - font.charHeight - 2,\n                1,\n                font\n            )\n        }\n    }\n\n    /**\n     * Set the effect that occurs when the game is over\n     * @param win whether the animation should run on a win (true)\n     * @param effect\n     */\n    export function setGameOverEffect(win: boolean, effect: effects.BackgroundEffect) {\n        init();\n        if (!effect) return;\n        if (win)\n            winEffect = effect;\n        else\n            loseEffect = effect;\n    }\n\n    /**\n     * Set the music that occurs when the player wins\n     * @param win\n     * @param effect\n     */\n    export function setGameOverSound(win: boolean, sound: music.Melody) {\n        init();\n        if (!sound) return;\n        if (win)\n            winSound = sound;\n        else\n            loseSound = sound;\n    }\n\n    /**\n     * Finish the game and display the score\n     */\n    //% group=\"Gameplay\"\n    //% blockId=gameOver block=\"game over || %win=toggleWinLose with %effect effect\"\n    //% weight=80 help=game/over\n    export function over(win: boolean = false, effect?: effects.BackgroundEffect) {\n        init();\n        if (__isOver) return;\n        __isOver = true;\n\n        if (!effect) {\n            effect = win ? winEffect : loseEffect;\n        }\n\n        // one last screenshot\n        takeScreenshot();\n\n        // releasing memory and clear fibers. Do not add anything that releases the fiber until background is set below,\n        // or screen will be cleared on the new frame and will not appear as background in the game over screen.\n        while (_sceneStack && _sceneStack.length) {\n            _scene.destroy();\n            popScene();\n        }\n        pushScene();\n        scene.setBackgroundImage(screen.clone());\n\n        if (win)\n            winSound.play();\n        else\n            loseSound.play();\n\n        effect.startScreenEffect();\n\n        pause(500);\n\n        game.eventContext().registerFrameHandler(95, () => {\n            let top = showDialogBackground(46, 4);\n            screen.printCenter(win ? \"YOU WIN!\" : \"GAME OVER!\", top + 8, screen.isMono ? 1 : 5, image.font8);\n            if (info.hasScore()) {\n                screen.printCenter(\"Score:\" + info.score(), top + 23, screen.isMono ? 1 : 2, image.font8);\n                if (info.score() > info.highScore()) {\n                    info.saveHighScore();\n                    screen.printCenter(\"New High Score!\", top + 34, screen.isMono ? 1 : 2, image.font5);\n                } else {\n                    screen.printCenter(\"HI\" + info.highScore(), top + 34, screen.isMono ? 1 : 2, image.font8);\n                }\n            }\n        });\n\n        pause(2000); // wait for users to stop pressing keys\n        waitAnyButton();\n        control.reset();\n    }\n\n    /**\n     * Tells the game host to grab a screenshot\n     */\n    //% shim=game::takeScreenshot\n    declare function takeScreenshot(): void;\n\n    /**\n     * Update the position and velocities of sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update weight=100 afterOnStart=true\n    //% blockId=gameupdate block=\"on game update\"\n    //% blockAllowMultiple=1\n    export function onUpdate(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(20, a);\n    }\n\n    /**\n     * Run code on an interval of time. This executes before game.onUpdate()\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/on-update-interval weight=99 afterOnStart=true\n    //% blockId=gameinterval block=\"on game update every %period=timePicker ms\"\n    //% blockAllowMultiple=1\n    export function onUpdateInterval(period: number, a: () => void): void {\n        init();\n        if (!a || period < 0) return;\n        let timer = 0;\n        game.eventContext().registerFrameHandler(19, () => {\n            const time = game.currentScene().millis();\n            if (timer <= time) {\n                timer = time + period;\n                a();\n            }\n        });\n    }\n\n    /**\n     * Draw on screen before sprites\n     * @param body code to execute\n     */\n    //% group=\"Gameplay\"\n    //% help=game/paint weight=10 afterOnStart=true\n    export function onPaint(a: () => void): void {\n        init();\n        if (!a) return;\n        game.eventContext().registerFrameHandler(75, a);\n    }\n\n    /**\n     * Returns the time since the game started in milliseconds\n     */\n    //% blockId=arcade_game_runtime block=\"time since start (ms)\"\n    //% group=\"Gameplay\" weight=11\n    //% help=game/runtime\n    export function runtime(): number {\n        return currentScene().millis();\n    }\n}\n","spritemap.ts":"// Add your code here\nnamespace sprites2 {\n    export class SpriteMap {\n        private cellWidth: number;\n        private cellHeight: number;\n        private rowCount: number;\n        private columnCount: number;\n        private buckets: Sprite[][];\n\n        constructor() {\n            this.buckets = [];\n        }\n\n        /**\n         * Returns a potential list of neighbors\n         */\n        neighbors(sprite: Sprite2): Sprite2[] {\n            if (this.isOob(sprite)) return [];\n\n            const n: Sprite2[] = [];\n            const layer = sprite.layer;\n            this.mergeAtKey(sprite.left, sprite.top, layer, n)\n            this.mergeAtKey(sprite.left, sprite.bottom, layer, n)\n            this.mergeAtKey(sprite.right, sprite.top, layer, n)\n            this.mergeAtKey(sprite.right, sprite.bottom, layer, n)\n            n.removeElement(sprite);\n            return n;\n        }\n\n        /**\n         * Gets the overlaping sprites if any\n         * @param sprite\n         */\n        overlaps(sprite: Sprite2): Sprite2[] {\n            const n = this.neighbors(sprite);\n            const o = n.filter(neighbor => sprite.overlapsWith(neighbor));\n            return o;\n        }\n\n        draw() {\n            for (let x = 0; x < this.columnCount; ++x) {\n                for (let y = 0; y < this.rowCount; ++y) {\n                    const left = x * this.cellWidth;\n                    const top = y * this.cellHeight;\n                    const k = this.key(left, top);\n                    const b = this.buckets[k];\n                    if (b && b.length)\n                        screen.drawRect(left, top, this.cellWidth, this.cellHeight, 5);\n                }\n            }\n        }\n\n        /**\n         * Recompute hashes for all objects\n         */\n        update(sprites: Sprite2[]) {\n            this.buckets = [];\n\n            // rescale buckets\n            let maxWidth = 0;\n            let maxHeight = 0;\n            for (const sprite of sprites) {\n                if (sprite.width > maxWidth) maxWidth = sprite.width;\n                if (sprite.height > maxHeight) maxHeight = sprite.height;\n            }\n\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n\n            this.cellWidth = Math.clamp(8, areaWidth >> 2, maxWidth * 2);\n            this.cellHeight = Math.clamp(8, areaHeight >> 2, maxHeight * 2);\n            this.rowCount = Math.idiv(areaHeight, this.cellHeight)\n            this.columnCount = Math.idiv(areaWidth, this.cellWidth)\n\n\n            for (const sprite of sprites)\n                this.insertAABB(sprite);\n        }\n\n        private key(x: number, y: number): number {\n            const xi = Math.clamp(0, this.columnCount, Math.idiv(x, this.cellWidth));\n            const yi = Math.clamp(0, this.rowCount, Math.idiv(y, this.cellHeight));\n            return xi + yi * this.columnCount;\n        }\n\n        private insertAtKey(x: number, y: number, sprite: Sprite2) {\n            const k = this.key(x, y);\n            let bucket = this.buckets[k];\n            if (!bucket)\n                bucket = this.buckets[k] = [];\n            if (bucket.indexOf(sprite) < 0)\n                bucket.push(sprite);\n        }\n\n        private isOob(sprite: Sprite2): boolean {\n            const tMap = game.currentScene().tileMap;\n\n            const areaWidth = tMap ? tMap.areaWidth() : screen.width;\n            const areaHeight = tMap ? tMap.areaHeight() : screen.height;\n            return sprite.right < 0 || sprite.left > areaWidth || sprite.bottom < 0 || sprite.top > areaHeight;\n        }\n\n        private insertAABB(sprite: Sprite2) {\n            // is object completely out of space?\n            if (this.isOob(sprite) || (sprite.flags & sprites.Flag.Ghost))\n                return;\n\n            const left = sprite.left;\n            const top = sprite.top;\n            const xn = Math.idiv(sprite.width + this.cellWidth - 1, this.cellWidth);\n            const yn = Math.idiv(sprite.height + this.cellHeight - 1, this.cellHeight);\n            for (let x = 0; x <= xn; x++)\n                for (let y = 0; y <= yn; y++)\n                    this.insertAtKey(left + Math.min(sprite.width, x * this.cellWidth), top + Math.min(sprite.height, y * this.cellHeight), sprite)\n        }\n\n        private mergeAtKey(x: number, y: number, layer: number, n: Sprite2[]) {\n            const k = this.key(x, y);\n            const bucket = this.buckets[k];\n            if (bucket) {\n                for (const sprite of bucket)\n                    if ((sprite.layer & layer)\n                        && n.indexOf(sprite) < 0)\n                        n.push(sprite);\n            }\n        }\n\n        toString() {\n            return `${this.buckets.length} buckets, ${this.buckets.filter(b => !!b).length} filled`;\n        }\n    }\n}","spriteset.ts":"/* \n* A set of sprites \n*/\nclass SpriteSet2 {\n    private _sprites: Sprite2[];\n\n    /**\n     * Create a new set from an array of sprites\n     * @param sprites \n     */\n    static createFromArray(sprites: Sprite2[]): SpriteSet2 {\n        const sp = new SpriteSet2();\n        const n = sprites.length;\n        for (let i = 0; i < n; ++i)\n            sp.add(sprites[i]);\n        return sp;\n    }\n\n    constructor() {\n        this._sprites = [];\n    }\n\n    /**\n     * Gets the number of sprites in the set\n     */\n    get length() {\n        return this._sprites.length;\n    }\n\n    /**\n     * Gets the snapshot of the current list of sprites\n     */\n    sprites() {\n        return this._sprites.slice(0, this._sprites.length);\n    }\n\n    /**\n     * Adds the sprite, returns true if added; false if the sprite was already in the set\n     * @param sprite \n     */\n    add(sprite: Sprite2): boolean {\n        if (!sprite) return false; // don't add nulls\n\n        // scan if in set\n        if (this.contains(sprite))\n            return false;\n        this._sprites.push(sprite);\n        return true;\n    }\n\n    /**\n     * Adds sprite and removes from old set. Returns true if sprite was in old set and not in new set.\n     * @param oldSet \n     * @param sprite \n     */\n    addFrom(oldSet: SpriteSet2, sprite: Sprite2): boolean {\n        const removed = oldSet.remove(sprite);\n        const added = this.add(sprite);\n        return removed && added;\n    }\n\n    /**\n     * Removes sprite from set. Returns true if the sprite was in the set\n     * @param sprite \n     */\n    remove(sprite: Sprite2): boolean {\n        const i = this._sprites.indexOf(sprite);\n        if (i > -1) {\n            this._sprites.splice(i, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the sprite is part of the set\n     * @param sprite \n     */\n    contains(sprite: Sprite2): boolean {\n        return this._sprites.indexOf(sprite) > -1;\n    }\n\n    /** \n     * Removes all the sprites from the set\n    */\n    clear() {\n        this._sprites.splice(0, this._sprites.length);\n    }\n\n    /**\n     * Removes the last sprite in the set\n     */\n    pop(): Sprite2 {\n        return this._sprites.pop();\n    }\n\n    toString() {\n        return `${this.length} sprites`\n    }\n}","hitbox.ts":"// Add your code here\nnamespace game2 {\n    export class Hitbox {\n        parent: Sprite2;\n        ox: number;\n        oy: number;\n        width: number;\n        height: number;\n\n        constructor(parent: Sprite2, width: number, height: number, ox: number, oy: number) {\n            this.width = width;\n            this.height = height;\n            this.parent = parent;\n            this.ox = ox;\n            this.oy = oy;\n        }\n\n        get left() {\n            return Fx.iadd(this.ox, this.parent._x)\n        }\n\n        get top() {\n            return Fx.iadd(this.oy, this.parent._y)\n        }\n\n        get right() {\n            return Fx.iadd(this.width - 1, this.left)\n        }\n\n        get bottom() {\n            return Fx.iadd(this.height - 1, this.top)\n        }\n    }\n\n\n    export function calculateHitBox(s: Sprite2): Hitbox {\n        const i = s.image;\n        let minX = i.width;\n        let minY = i.height;\n        let maxX = 0;\n        let maxY = 0;\n\n        for (let c = 0; c < i.width; c++) {\n            for (let r = 0; r < i.height; r++) {\n                if (i.getPixel(c, r)) {\n                    minX = Math.min(minX, c);\n                    minY = Math.min(minY, r);\n                    maxX = Math.max(maxX, c);\n                    maxY = Math.max(maxY, r);\n                }\n            }\n        }\n\n        const width = maxX - minX + 1;\n        const height = maxY - minY + 1;\n\n        return new Hitbox(s, width, height, minX, minY);\n    }\n}","pxt.json":"{\n    \"name\": \"fix\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"sprite.ts\",\n        \"sprites.ts\",\n        \"physics.ts\",\n        \"tilemap.ts\",\n        \"scene.ts\",\n        \"game.ts\",\n        \"spritemap.ts\",\n        \"spriteset.ts\",\n        \"hitbox.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1756167958897}